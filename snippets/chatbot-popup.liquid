<!-- CHATBOT POPUP v4.1 - UPDATED 23/10/2025 - Dynamic Settings + Socket.IO Real-time + New API Endpoints - Compatible with chatbot-lucy-2025 backend -->
<!-- ‚ú® NEW: Loads widget configuration (colors, position, greeting) from dashboard settings via /api/settings/public -->

<!-- Socket.IO Client CDN -->
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>

<style>
/* Chatbot Popup Styles - Aligned with theme */
:root {
  --christmas-red: #dc2626;    /* rosso natalizio */
  --christmas-green: #059669;  /* verde abete */
  --christmas-gold: #f59e0b;   /* oro natalizio */
  --christmas-cream: #fef7ed;  /* crema natalizia */
  --background-dark: #1a1a1a;  /* sfondo scuro */
  --text-light: #ffffff;       /* testo bianco */
  --text-gray: #e5e7eb;        /* testo grigio chiaro */
}

.chatbot-container {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 9999;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, Helvetica, sans-serif;
}

/* Chat Bubble - Theme Aligned */
.chat-bubble {
  width: 60px;
  height: 60px;
  background: rgba(255, 255, 255, 0.1);
  border: 2px solid rgba(255, 255, 255, 0.3);
  backdrop-filter: blur(10px);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  transition: all 0.3s ease;
  position: relative;
}

.chat-bubble:hover {
  background: rgba(255, 255, 255, 0.2);
  border-color: rgba(255, 255, 255, 0.5);
  transform: scale(1.05);
  box-shadow: 0 6px 25px rgba(0,0,0,0.4);
}

.chat-bubble-icon {
  width: 28px;
  height: 28px;
  fill: white;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

/* Notification Badge */
.chat-notification {
  position: absolute;
  top: -8px;
  right: -8px;
  background: var(--christmas-gold);
  color: var(--christmas-red);
  border-radius: 50%;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
  animation: bounce 1s infinite;
}

@keyframes bounce {
  0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
  40% { transform: translateY(-5px); }
  60% { transform: translateY(-3px); }
}

/* Chat Popup */
.chat-popup {
  position: absolute;
  bottom: 80px;
  right: 0;
  width: 400px;
  height: 600px;
  background: rgba(26, 26, 26, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 20px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.4);
  border: 2px solid rgba(5, 150, 105, 0.3);
  display: none;
  flex-direction: column;
  overflow: hidden;
  animation: slideUp 0.3s ease;
}

/* Mobile responsive */
@media (max-width: 480px) {
  .chat-popup {
    width: calc(100vw - 40px);
    height: calc(100vh - 120px);
    bottom: 80px;
    right: 20px;
    left: 20px;
  }

  .chat-popup.expanded {
    width: 100vw;
    height: 100vh;
    top: 0;
    bottom: 0;
    right: 0;
    left: 0;
    border-radius: 0;
    border: none;
  }
}

/* Desktop expanded mode */
@media (min-width: 768px) {
  .chat-popup.expanded {
    background: rgba(26, 26, 26, 0.98);
    backdrop-filter: blur(30px);
    border: 2px solid rgba(5, 150, 105, 0.4);
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
  }
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.chat-popup.show {
  display: flex;
}

/* Popup Header */
.chat-header {
  background: var(--christmas-red);
  color: white;
  padding: 1rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.chat-title {
  font-size: 1.125rem;
  font-weight: normal;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

/* Header controls */
.chat-controls {
  display: flex;
  gap: 8px;
}

.chat-close {
  background: none;
  border: none;
  color: var(--text-light);
  font-size: 18px;
  cursor: pointer;
  padding: 0;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.chat-close:hover {
  background: rgba(255,255,255,0.15);
  transform: scale(1.05);
}

/* Messages Area */
.chat-messages {
  flex: 1;
  overflow-y: auto;
  padding: 1rem;
  background: rgba(26, 26, 26, 0.8);
  backdrop-filter: blur(10px);
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.chat-message {
  display: flex;
  flex-direction: column;
  animation: fadeInMessage 0.3s ease;
}

@keyframes fadeInMessage {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* P0.5: Typing indicator animation */
.typing-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background-color: #666;
  animation: typingDot 1.4s infinite;
}

.typing-dot:nth-child(2) {
  animation-delay: 0.2s;
}

.typing-dot:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes typingDot {
  0%, 60%, 100% { transform: translateY(0); opacity: 0.7; }
  30% { transform: translateY(-10px); opacity: 1; }
}

.chat-message.user {
  align-items: flex-end;
}

.chat-message.bot {
  align-items: flex-start;
}

.chat-message.operator {
  align-items: flex-start;
}

.chat-message.system {
  align-items: center;
}

.message-bubble {
  max-width: 80%;
  padding: 0.75rem 1rem;
  border-radius: 18px;
  font-size: 1rem !important;
  line-height: 1.6 !important;
  word-wrap: break-word;
  font-weight: 400 !important;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif !important;
}

.message-bubble *, .message-bubble p, .message-bubble div, .message-bubble span {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif !important;
  font-size: 1rem !important;
  line-height: 1.6 !important;
  font-weight: 400 !important;
}

.user .message-bubble {
  background: var(--christmas-green);
  color: white;
  border-bottom-right-radius: 6px;
}

.bot .message-bubble {
  background: var(--christmas-green);
  color: white;
  border-bottom-left-radius: 6px;
}

.operator .message-bubble {
  background: linear-gradient(135deg, #10B981, #059669);
  color: white;
  border-bottom-left-radius: 6px;
  border-left: 3px solid #34D399;
}

/* Operator name styling */
.operator-name {
  font-weight: 600;
  opacity: 0.9;
  font-size: 0.85em;
  margin-right: 0.4em;
  display: inline-block;
  padding: 2px 6px;
  background: rgba(255, 255, 255, 0.2);
  border-radius: 4px;
}

.system .message-bubble {
  background: rgba(255, 255, 255, 0.1);
  color: var(--text-gray);
  border: 1px solid rgba(255, 255, 255, 0.2);
  font-size: 0.9rem !important;
  text-align: center;
  font-style: italic;
}

/* Input Area */
.chat-input-container {
  padding: 1rem;
  background: rgba(26, 26, 26, 0.9);
  backdrop-filter: blur(15px);
  border-top: 1px solid rgba(255,255,255,0.1);
}

.chat-input-group {
  display: flex;
  gap: 0.5rem;
  align-items: flex-end;
}

.chat-input-field {
  flex: 1;
  background: rgba(45, 45, 45, 0.8);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255,255,255,0.3);
  color: white;
  padding: 0.75rem;
  border-radius: 20px;
  font-size: 1rem;
  line-height: 1.4;
  resize: none;
  max-height: 100px;
  min-height: 40px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, Helvetica, sans-serif;
}

.chat-input-field:focus {
  outline: none;
  border-color: var(--christmas-green);
  background: rgba(61, 61, 61, 0.9);
  backdrop-filter: blur(15px);
}

.chat-input-field::placeholder {
  color: rgba(255,255,255,0.6);
}

.chat-send-button {
  background: var(--christmas-red);
  border: none;
  color: white;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
  flex-shrink: 0;
}

.chat-send-button:hover:not(:disabled) {
  background: var(--christmas-green);
  transform: scale(1.1);
}

.chat-send-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* P0.1: Upload Button */
.chat-upload-button {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255,255,255,0.2);
  color: white;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
  flex-shrink: 0;
  font-size: 1.2rem;
}

.chat-upload-button:hover:not(:disabled) {
  background: rgba(255, 255, 255, 0.2);
  transform: scale(1.1);
}

.chat-upload-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.chat-upload-button.uploading {
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* Typing Indicator */
.typing-indicator {
  display: none;
  padding: 0.5rem 1rem;
  color: var(--text-gray);
  font-style: italic;
  font-size: 0.95rem;
  font-weight: 400;
  line-height: 1.4;
}

.typing-indicator.show {
  display: block;
}

.typing-dots {
  display: inline-block;
}

.typing-dots span {
  animation: typingDot 1.4s infinite;
  font-size: 1.2em;
}

.typing-dots span:nth-child(1) { animation-delay: 0s; }
.typing-dots span:nth-child(2) { animation-delay: 0.2s; }
.typing-dots span:nth-child(3) { animation-delay: 0.4s; }

@keyframes typingDot {
  0%, 60%, 100% { opacity: 0.3; }
  30% { opacity: 1; }
}

/* Chat Links */
.chat-link {
  display: inline-block;
  padding: 8px 16px;
  margin: 4px 2px;
  border-radius: 20px;
  text-decoration: none;
  font-weight: 600;
  font-size: 14px;
  transition: all 0.3s ease;
  border: 2px solid transparent;
  cursor: pointer;
}

.chat-link:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  text-decoration: none;
}

.product-link {
  background: linear-gradient(135deg, var(--christmas-red), #d32f2f);
  color: white;
  border-color: var(--christmas-red);
}

.product-link:hover {
  background: linear-gradient(135deg, #d32f2f, var(--christmas-red));
  color: white;
  border-color: #d32f2f;
}

.cart-link {
  background: linear-gradient(135deg, var(--christmas-gold), #f57c00);
  color: var(--christmas-red);
  border-color: var(--christmas-gold);
}

.cart-link:hover {
  background: linear-gradient(135deg, #f57c00, var(--christmas-gold));
  color: var(--christmas-red);
  border-color: #f57c00;
}

.email-link {
  background: linear-gradient(135deg, #4CAF50, #45a049);
  color: white;
  border-color: #4CAF50;
}

.email-link:hover {
  background: linear-gradient(135deg, #45a049, #4CAF50);
  color: white;
  border-color: #45a049;
}

.whatsapp-link {
  background: linear-gradient(135deg, #25D366, #128C7E);
  color: white;
  border-color: #25D366;
}

.whatsapp-link:hover {
  background: linear-gradient(135deg, #128C7E, #25D366);
  color: white;
  border-color: #128C7E;
}

/* Smart Actions */
.smart-actions-container {
  margin: 1rem 0;
  padding: 0 1rem;
}

.smart-actions-grid {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.smart-action-button {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  border: none;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.3s ease;
  text-align: left;
  font-family: inherit;
  width: 100%;
  background: rgba(255, 255, 255, 0.1);
  border: 2px solid rgba(255, 255, 255, 0.3);
  color: var(--text-light);
}

.smart-action-button.primary {
  background: linear-gradient(135deg, var(--christmas-red), rgba(220, 38, 38, 0.8));
  backdrop-filter: blur(10px);
  color: white;
  border-color: var(--christmas-red);
  box-shadow: 0 4px 15px rgba(220, 38, 38, 0.3);
}

.smart-action-button.success {
  background: linear-gradient(135deg, var(--christmas-gold), rgba(245, 158, 11, 0.8));
  backdrop-filter: blur(10px);
  color: var(--background-dark);
  border-color: var(--christmas-gold);
  box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
}

.smart-action-button.info {
  background: linear-gradient(135deg, var(--christmas-green), rgba(5, 150, 105, 0.8));
  backdrop-filter: blur(10px);
  color: white;
  border-color: var(--christmas-green);
  box-shadow: 0 4px 15px rgba(5, 150, 105, 0.3);
}

.smart-action-button.secondary {
  background: linear-gradient(135deg, rgba(102, 102, 102, 0.8), rgba(85, 85, 85, 0.8));
  backdrop-filter: blur(10px);
  color: white;
  border-color: rgba(102, 102, 102, 0.6);
  box-shadow: 0 4px 15px rgba(102, 102, 102, 0.2);
}

.smart-action-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(0,0,0,0.3);
  backdrop-filter: blur(15px);
}

.smart-action-button:active {
  transform: translateY(0);
}

.action-icon {
  font-size: 1.5rem;
  flex-shrink: 0;
}

.action-content {
  flex: 1;
  min-width: 0;
}

.action-text {
  font-weight: normal;
  font-size: 1rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 0.25rem;
}

.action-description {
  font-size: 0.9rem;
  opacity: 0.8;
  line-height: 1.4;
  font-weight: 400;
}

/* Waiting for operator UI */
.waiting-operator-message {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 16px;
  background: linear-gradient(135deg, #FFF4E6 0%, #FFE5CC 100%);
  border-radius: 12px;
  margin-bottom: 10px;
  border: 2px solid #FFB84D;
}

.waiting-icon {
  font-size: 2rem;
  flex-shrink: 0;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.7; transform: scale(1.1); }
}

.waiting-text {
  flex: 1;
}

.waiting-text strong {
  display: block;
  color: #B87300;
  font-size: 1rem;
  margin-bottom: 4px;
}

.waiting-text p {
  margin: 0;
  color: #8B5A00;
  font-size: 0.9rem;
  line-height: 1.4;
}

/* Loading indicator */
.chat-loading-indicator {
  display: flex;
  justify-content: center;
  padding: 1rem;
  animation: fadeIn 0.2s ease-in;
}

.loading-content {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  background: #f0f0f0;
  padding: 0.75rem 1.25rem;
  border-radius: 20px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.spinner {
  width: 16px;
  height: 16px;
  border: 2px solid #e0e0e0;
  border-top-color: #f4c430;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

.loading-text {
  font-size: 0.9rem;
  color: #666;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .chat-popup {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    border-radius: 0;
    animation: slideUpMobile 0.3s ease;
  }

  @keyframes slideUpMobile {
    from { transform: translateY(100%); }
    to { transform: translateY(0); }
  }

  .chatbot-container {
    bottom: 15px;
    right: 15px;
  }

  .chat-bubble {
    width: 55px;
    height: 55px;
  }
}

</style>

<!-- Chatbot Container -->
<div class="chatbot-container" id="chatbotContainer" style="display: none;">
  <!-- Chat Bubble -->
  <div class="chat-bubble" id="chatBubble">
    <div class="chat-bubble-icon">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M20 2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h4l4 4 4-4h4c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/>
      </svg>
    </div>
    <div class="chat-notification" id="chatNotification" style="display: none;">0</div>
  </div>

  <!-- Chat Popup -->
  <div class="chat-popup" id="chatPopup">
    <!-- Header -->
    <div class="chat-header">
      <div class="chat-title" style="font-family: 'Lucine di Natale', -apple-system, sans-serif; text-transform: uppercase;">
        LUCY - ASSISTENTE VIRTUALE
      </div>
      <div class="chat-controls">
        <!-- v2.3.5: ISSUE #10 - Return to AI button (only visible in operator mode) -->
        <button id="returnToAIBtn" onclick="returnToAI()" title="Torna all'assistente AI" style="
          display: none;
          background: rgba(255, 255, 255, 0.2);
          border: 1px solid rgba(255, 255, 255, 0.3);
          color: white;
          padding: 6px 12px;
          border-radius: 6px;
          cursor: pointer;
          font-size: 13px;
          margin-right: 8px;
          transition: all 0.2s;
        " onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'">
          ü§ñ Torna all'AI
        </button>
        <!-- v2.3.7: BUG #1 - End conversation button (always visible) -->
        <button id="endConversationBtn" onclick="endConversation()" title="Termina conversazione e ricomincia" style="
          background: rgba(239, 68, 68, 0.2);
          border: 1px solid rgba(239, 68, 68, 0.3);
          color: white;
          padding: 6px 12px;
          border-radius: 6px;
          cursor: pointer;
          font-size: 13px;
          margin-right: 8px;
          transition: all 0.2s;
        " onmouseover="this.style.background='rgba(239, 68, 68, 0.3)'" onmouseout="this.style.background='rgba(239, 68, 68, 0.2)'">
          üî¥ Termina
        </button>
        <button class="chat-close" id="chatClose" title="Chiudi chat">√ó</button>
      </div>
    </div>

    <!-- Messages -->
    <div class="chat-messages" id="chatMessages">
      <!-- Messaggi benvenuto gi√† come bubble -->
      <div class="chat-message bot">
        <div class="message-bubble">
          Ciao! Sono Lucy, il tuo assistente virtuale. üëã
        </div>
      </div>
      <div class="chat-message bot">
        <div class="message-bubble">
          Chiedimi quello che vuoi sapere.<br>Se non troviamo una risposta, ti metter√≤ in contatto con un operatore!
        </div>
      </div>
    </div>

    <!-- Typing Indicator -->
    <div class="typing-indicator" id="typingIndicator">
      L'assistente sta scrivendo<span class="typing-dots"><span>.</span><span>.</span><span>.</span></span>
    </div>

    <!-- Input -->
    <div class="chat-input-container">
      <div class="chat-input-group">
        <!-- P0.1: Hidden file input -->
        <input type="file" id="chatFileInput" accept="image/*,.pdf,.doc,.docx,.xls,.xlsx,.txt,.csv,.zip,.rar" style="display: none;">

        <!-- P0.1: Upload button -->
        <button class="chat-upload-button" id="chatUploadButton" title="Carica file">
          üìé
        </button>

        <textarea
          class="chat-input-field"
          id="chatInputField"
          placeholder="Scrivi la tua domanda..."
          rows="1"
        ></textarea>
        <button class="chat-send-button" id="chatSendButton">
          üì§
        </button>
      </div>
    </div>
  </div>
</div>

<script>
// Inizializza chatbot solo se c'√® il parametro URL
document.addEventListener('DOMContentLoaded', function() {
  const urlParams = new URLSearchParams(window.location.search);

  if (urlParams.get('chatbot') === 'test' || urlParams.get('pb') === '0') {
    initializeChatbot();
  }
});

function initializeChatbot() {
  console.log('ü§ñ Chatbot v4.1 - Dynamic Settings + Socket.IO');
  const container = document.getElementById('chatbotContainer');
  const bubble = document.getElementById('chatBubble');
  const popup = document.getElementById('chatPopup');
  const closeBtn = document.getElementById('chatClose');
  const input = document.getElementById('chatInputField');
  const sendBtn = document.getElementById('chatSendButton');
  const messagesContainer = document.getElementById('chatMessages');
  const typingIndicator = document.getElementById('typingIndicator');
  const notification = document.getElementById('chatNotification');

  // Configurazione - UPDATED ENDPOINTS
  const BACKEND_URL = 'https://chatbot-lucy-2025.onrender.com';
  const SOCKET_URL = 'https://chatbot-lucy-2025.onrender.com';

  // ‚úÖ LOAD DYNAMIC SETTINGS FROM BACKEND
  let widgetSettings = {
    primaryColor: '#dc2626',
    position: 'bottom-right',
    greeting: 'Ciao! Sono Lucy, il tuo assistente virtuale. üëã',
    title: 'LUCY - ASSISTENTE VIRTUALE',
    subtitle: 'Chiedimi quello che vuoi sapere.'
  };

  // BUG #7 FIX: Store interval reference for cleanup
  let settingsRefreshInterval = null;

  // P2.5: Dynamic badge counter for unread messages
  let unreadMessageCount = 0;

  // P2.6: Audio notification for new messages
  const notificationAudio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBDGH0fPTgjMGHm7A7+OZWQ==');
  let audioUnlocked = false; // Track if audio context is unlocked

  // P2.6: Play notification sound
  function playNotificationSound() {
    if (!audioUnlocked) {
      console.log('üîá Audio not unlocked yet');
      return;
    }

    notificationAudio.currentTime = 0;
    notificationAudio.play()
      .then(() => console.log('üîî Notification sound played'))
      .catch(e => console.log('üîá Audio play failed:', e.message));
  }

  // P2.6: Unlock audio on first user interaction
  function unlockAudio() {
    if (audioUnlocked) return;

    notificationAudio.play()
      .then(() => {
        notificationAudio.pause();
        notificationAudio.currentTime = 0;
        audioUnlocked = true;
        console.log('üîì Audio context unlocked');
      })
      .catch(() => {
        console.log('üîí Audio unlock failed');
      });
  }

  // P2.7: Browser notifications
  let notificationPermissionRequested = false;

  // P2.7: Request notification permission after first message
  function requestNotificationPermission() {
    if (notificationPermissionRequested) return;
    if (!('Notification' in window)) return;
    if (Notification.permission === 'granted' || Notification.permission === 'denied') return;

    notificationPermissionRequested = true;
    Notification.requestPermission().then(permission => {
      console.log('üîî Notification permission:', permission);
    });
  }

  // P2.7: Show browser notification
  function showBrowserNotification(title, body, data = {}) {
    if (!('Notification' in window)) {
      console.log('üö´ Browser notifications not supported');
      return;
    }

    if (Notification.permission !== 'granted') {
      console.log('üîï Notification permission not granted');
      return;
    }

    // Don't notify if document has focus and popup is open
    if (document.hasFocus() && isPopupOpen) {
      console.log('üëÄ User is watching - skipping notification');
      return;
    }

    try {
      const notification = new Notification(title, {
        body: body,
        icon: 'https://lucinedinatale.it/cdn/shop/files/logo_bianco_512.png?v=1730272455',
        badge: 'https://lucinedinatale.it/cdn/shop/files/logo_bianco_512.png?v=1730272455',
        tag: 'lucine-chatbot',
        requireInteraction: false,
        silent: false, // Play default sound
        data: data
      });

      // Auto-close after 5 seconds
      setTimeout(() => notification.close(), 5000);

      // Handle click - focus window and open popup
      notification.onclick = () => {
        window.focus();
        if (!isPopupOpen) {
          popup.classList.add('show');
          isPopupOpen = true;
          updateBadge(0);
        }
        notification.close();
      };

      console.log('‚úÖ Browser notification shown:', title);
    } catch (error) {
      console.log('‚ùå Failed to show notification:', error.message);
    }
  }

  // P2.5: Update badge with current unread count
  function updateBadge(count) {
    unreadMessageCount = Math.max(0, count); // Ensure non-negative

    if (unreadMessageCount > 0) {
      notification.textContent = unreadMessageCount > 9 ? '9+' : unreadMessageCount.toString();
      notification.style.display = 'flex';
    } else {
      notification.style.display = 'none';
    }

    console.log(`üì¨ Badge updated: ${unreadMessageCount} unread messages`);
  }

  // P2.1: Fetch settings from backend with cache busting
  async function loadWidgetSettings(skipCache = false) {
    try {
      console.log('‚öôÔ∏è Loading widget settings...');

      // P2.1: Add cache-busting timestamp to prevent stale cached settings
      const cacheBuster = skipCache ? `?t=${Date.now()}` : '';
      const response = await fetch(`${BACKEND_URL}/api/settings/public${cacheBuster}`, {
        cache: skipCache ? 'no-cache' : 'default'
      });

      if (response.ok) {
        const data = await response.json();
        if (data.success && data.data) {
          // P2.1: Check if settings version changed
          const previousVersion = localStorage.getItem('widgetSettingsVersion');
          const newVersion = data.data.version;

          widgetSettings = { ...widgetSettings, ...data.data };
          console.log('‚úÖ Settings loaded:', widgetSettings);

          // P2.1: Store version for change detection
          if (newVersion) {
            localStorage.setItem('widgetSettingsVersion', newVersion);

            // If version changed and widget was already loaded, reapply settings
            if (previousVersion && previousVersion !== String(newVersion)) {
              console.log('üîÑ Settings version changed, reapplying...');
            }
          }

          applySettings();
        }
      } else {
        console.warn('‚ö†Ô∏è Failed to load settings, using defaults');
      }
    } catch (error) {
      console.error('‚ùå Error loading settings:', error);
      console.log('Using default settings');
    }
  }

  // P2.1: Auto-refresh settings every 5 minutes to catch dashboard changes
  function startSettingsAutoRefresh() {
    // BUG #7 FIX: Clear existing interval to prevent memory leak
    if (settingsRefreshInterval) {
      clearInterval(settingsRefreshInterval);
    }

    // BUG #7 FIX: Store interval reference for cleanup
    settingsRefreshInterval = setInterval(() => {
      console.log('üîÑ Auto-refreshing widget settings...');
      loadWidgetSettings(true); // Skip cache on auto-refresh
    }, 5 * 60 * 1000); // 5 minutes
  }

  // Apply settings to widget
  function applySettings() {
    // Apply primary color
    if (widgetSettings.primaryColor) {
      document.documentElement.style.setProperty('--christmas-red', widgetSettings.primaryColor);
      console.log('üé® Applied primary color:', widgetSettings.primaryColor);
    }

    // Apply position
    if (widgetSettings.position) {
      const positions = {
        'bottom-right': { bottom: '20px', right: '20px', left: 'auto', top: 'auto' },
        'bottom-left': { bottom: '20px', left: '20px', right: 'auto', top: 'auto' },
        'top-right': { top: '20px', right: '20px', left: 'auto', bottom: 'auto' },
        'top-left': { top: '20px', left: '20px', right: 'auto', bottom: 'auto' }
      };

      const pos = positions[widgetSettings.position] || positions['bottom-right'];
      Object.assign(container.style, pos);
      console.log('üìç Applied position:', widgetSettings.position);
    }

    // Apply title
    if (widgetSettings.title) {
      const titleElement = document.querySelector('.chat-title');
      if (titleElement) {
        titleElement.textContent = widgetSettings.title.toUpperCase();
        console.log('üìù Applied title:', widgetSettings.title);
      }
    }

    // Update welcome messages
    updateWelcomeMessages();
  }

  // Update welcome messages with settings
  function updateWelcomeMessages() {
    const welcomeMessages = messagesContainer.querySelectorAll('.chat-message.bot');
    if (welcomeMessages.length >= 2 && widgetSettings.greeting && widgetSettings.subtitle) {
      welcomeMessages[0].querySelector('.message-bubble').textContent = widgetSettings.greeting;
      welcomeMessages[1].querySelector('.message-bubble').innerHTML = widgetSettings.subtitle;
      console.log('üí¨ Updated welcome messages');
    }
  }

  // Load settings immediately
  loadWidgetSettings();

  // P2.1: Start auto-refresh to keep settings updated
  startSettingsAutoRefresh();

  // Mostra il container
  container.style.display = 'block';

  // Session persistence constants
  const SESSION_STORAGE_KEY = 'lucine_chat_session_id';
  const SESSION_EXPIRY_KEY = 'lucine_chat_session_expiry';
  const SESSION_TTL = 7 * 24 * 60 * 60 * 1000; // 7 days

  // Session persistence functions
  function loadSessionId() {
    try {
      const storedId = localStorage.getItem(SESSION_STORAGE_KEY);
      const expiry = localStorage.getItem(SESSION_EXPIRY_KEY);

      if (storedId && expiry) {
        const expiryDate = new Date(expiry);
        if (expiryDate > new Date()) {
          console.log('‚úÖ Restored session from localStorage:', storedId);
          return storedId;
        } else {
          console.log('‚ö†Ô∏è Session expired, clearing storage');
          clearSessionStorage();
        }
      }
    } catch (error) {
      console.error('‚ùå Error loading session:', error);
    }
    return null;
  }

  // FIX: Validate restored session and check if needs resume prompt
  async function validateRestoredSession(storedSessionId) {
    if (!storedSessionId) return null;

    try {
      console.log('üîç Validating restored session:', storedSessionId);
      const response = await fetch(`${BACKEND_URL}/api/chat/session/${storedSessionId}`);

      if (!response.ok) {
        if (response.status === 410) {
          console.log('‚ö†Ô∏è Session expired (>7 days), clearing localStorage');
        } else {
          console.log('‚ùå Session not found on server, clearing localStorage');
        }
        clearSessionStorage();
        return null;
      }

      const sessionData = await response.json();
      console.log('üìä Session validation response:', sessionData.data);

      const session = sessionData.data || sessionData;
      const status = session.status;

      // Check if session is closed or converted to ticket
      if (status === 'CLOSED' || status === 'TICKET_CREATED') {
        console.log('üö´ Session is closed, clearing localStorage');
        clearSessionStorage();
        return null;
      }

      // If WITH_OPERATOR, ask user if they want to resume
      if (status === 'WITH_OPERATOR') {
        console.log('üë§ Session has operator - showing resume prompt');
        return { sessionId: storedSessionId, needsResume: true, operatorName: session.operator?.name };
      }

      console.log('‚úÖ Session is valid and active');
      return { sessionId: storedSessionId, needsResume: false };
    } catch (error) {
      console.error('‚ùå Error validating session:', error);
      clearSessionStorage();
      return null;
    }
  }

  function saveSessionId(id) {
    try {
      const expiry = new Date(Date.now() + SESSION_TTL);
      localStorage.setItem(SESSION_STORAGE_KEY, id);
      localStorage.setItem(SESSION_EXPIRY_KEY, expiry.toISOString());
      console.log('üíæ Session saved to localStorage:', id);
    } catch (error) {
      console.error('‚ùå Error saving session:', error);
    }
  }

  function clearSessionStorage() {
    try {
      localStorage.removeItem(SESSION_STORAGE_KEY);
      localStorage.removeItem(SESSION_EXPIRY_KEY);
      console.log('üóëÔ∏è Session storage cleared');
    } catch (error) {
      console.error('‚ùå Error clearing session:', error);
    }
  }

  // Try to restore session from localStorage
  let sessionId = loadSessionId();
  let sessionValidated = false; // Track if we validated the restored session
  let pendingResumeSession = null; // Store session info if needs resume prompt

  let isPopupOpen = false;
  let isOperatorMode = false;
  let userName = null; // v2.3.4: Track user name for pre-filling ticket form
  let socket = null; // Socket.IO connection
  const displayedMessageIds = new Set(); // Track displayed messages globally

  // Inactivity timeout variables
  let lastUserActivity = Date.now();
  let inactivityCheckInterval = null;
  let inactivityWarningShown = false;
  const INACTIVITY_WARNING_TIME = 3 * 60 * 1000; // 3 minutes
  const INACTIVITY_FINAL_TIME = 5 * 60 * 1000; // 5 minutes

  // Network quality detection variables
  let isOnline = navigator.onLine;
  let messageQueue = []; // Queue messages when offline
  let reconnectAttempts = 0;
  const MAX_RECONNECT_ATTEMPTS = 5;

  // Typing indicator timeout
  let typingIndicatorTimeout = null;

  // FIX: Validate restored session on page load
  (async function initializeSession() {
    if (sessionId && !sessionValidated) {
      const validationResult = await validateRestoredSession(sessionId);
      sessionValidated = true;

      if (!validationResult) {
        // Session invalid/closed - start fresh
        console.log('üí° Starting fresh - no valid session to restore');
        sessionId = null;
      } else if (validationResult.needsResume) {
        // Session WITH_OPERATOR - show resume prompt
        console.log('üìã Session with operator found - prompting user to resume');
        pendingResumeSession = validationResult;
        sessionId = null; // Don't auto-join yet
        showResumePrompt(validationResult.operatorName);
      } else {
        // Session ACTIVE/WAITING - restore normally
        console.log('‚úÖ Restoring active session');
        sessionId = validationResult.sessionId;
      }
    }
  })();

  // üîó Check if URL has ticket token for resume
  const urlParams = new URLSearchParams(window.location.search);
  const ticketToken = urlParams.get('ticket');
  if (ticketToken) {
    console.log('üé´ Ticket token found in URL:', ticketToken);
    resumeChatFromTicket(ticketToken);
  }

  // Event Listeners
  bubble.addEventListener('click', togglePopup);
  closeBtn.addEventListener('click', closePopup);
  sendBtn.addEventListener('click', () => sendMessage());
  input.addEventListener('keypress', handleKeyPress);
  input.addEventListener('input', autoResize);
  input.addEventListener('input', handleUserTyping); // P0.5: Typing indicator

  // Network quality detection listeners
  window.addEventListener('online', handleOnline);
  window.addEventListener('offline', handleOffline);
  console.log('üåê Network listeners initialized');

  // P0.1: File Upload Event Listeners
  const uploadBtn = document.getElementById('chatUploadButton');
  const fileInput = document.getElementById('chatFileInput');

  uploadBtn.addEventListener('click', () => {
    fileInput.click();
  });

  fileInput.addEventListener('change', async (event) => {
    const file = event.target.files?.[0];
    if (!file) return;

    // Validate file size (10MB max)
    if (file.size > 10 * 1024 * 1024) {
      alert('File troppo grande. Dimensione massima: 10MB');
      fileInput.value = '';
      return;
    }

    if (!sessionId) {
      alert('Sessione non attiva. Riprova.');
      fileInput.value = '';
      return;
    }

    // Show uploading state
    uploadBtn.disabled = true;
    uploadBtn.classList.add('uploading');
    uploadBtn.textContent = '‚è≥';

    try {
      const formData = new FormData();
      formData.append('file', file);

      const response = await fetch(`${BACKEND_URL}/api/chat/sessions/${sessionId}/upload`, {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error?.message || 'Errore durante l\'upload');
      }

      const data = await response.json();
      console.log('‚úÖ P0.1: File uploaded:', data);

      // Message will be displayed via WebSocket

      // Clear file input
      fileInput.value = '';
    } catch (error) {
      console.error('Upload error:', error);
      alert(error.message || 'Errore durante l\'upload del file');
    } finally {
      // Restore button state
      uploadBtn.disabled = false;
      uploadBtn.classList.remove('uploading');
      uploadBtn.textContent = 'üìé';
    }
  });

  // P2.5: Show badge after 3 seconds if popup is closed (optional welcome prompt)
  setTimeout(() => {
    if (!isPopupOpen && unreadMessageCount === 0) {
      // Show "1" as a prompt to open the chat (not a real unread message)
      updateBadge(1);
    }
  }, 3000);

  function togglePopup() {
    if (isPopupOpen) {
      closePopup();
    } else {
      openPopup();
    }
  }

  function openPopup() {
    popup.classList.add('show');
    isPopupOpen = true;

    // P2.5: Reset badge when opening popup
    updateBadge(0);

    setTimeout(() => input.focus(), 300);
  }

  function closePopup() {
    popup.classList.remove('show');
    isPopupOpen = false;
  }

  function handleKeyPress(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  }

  function autoResize() {
    input.style.height = 'auto';
    input.style.height = Math.min(input.scrollHeight, 100) + 'px';
  }

  // P0.5: User typing indicator
  let typingTimeout = null;
  function handleUserTyping() {
    if (!socket || !socket.connected || !sessionId) return;

    // Emit typing started
    socket.emit('user_typing', {
      sessionId: sessionId,
      isTyping: true,
    });

    // Clear previous timeout
    if (typingTimeout) {
      clearTimeout(typingTimeout);
    }

    // Stop typing after 1 second of inactivity
    typingTimeout = setTimeout(() => {
      if (socket && socket.connected && sessionId) {
        socket.emit('user_typing', {
          sessionId: sessionId,
          isTyping: false,
        });
      }
    }, 1000);
  }

  // P0.5: Show operator typing indicator with auto-timeout
  function showTypingIndicator(isTyping, operatorName) {
    const existingIndicator = document.getElementById('typing-indicator');

    // Clear existing timeout
    if (typingIndicatorTimeout) {
      clearTimeout(typingIndicatorTimeout);
      typingIndicatorTimeout = null;
    }

    if (isTyping) {
      // Create typing indicator if not exists
      if (!existingIndicator) {
        const indicator = document.createElement('div');
        indicator.id = 'typing-indicator';
        indicator.className = 'chat-message operator-message';
        indicator.innerHTML = `
          <div class="message-content">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span>${operatorName || 'Operatore'} sta scrivendo</span>
              <div style="display: flex; gap: 4px;">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
              </div>
            </div>
          </div>
        `;
        messagesContainer.appendChild(indicator);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }

      // Auto-remove after 10 seconds if no "stop typing" event received
      // (Increased from 5s to 10s for operators who type slowly)
      typingIndicatorTimeout = setTimeout(() => {
        const indicator = document.getElementById('typing-indicator');
        if (indicator) {
          console.log('‚è±Ô∏è  Auto-removing stuck typing indicator');
          indicator.remove();
        }
      }, 10000);
    } else {
      // Remove typing indicator
      if (existingIndicator) {
        existingIndicator.remove();
      }
    }
  }

  // P1.2: Show rating popup after chat closed (CSAT)
  function showRatingPopup(sessionId) {
    // Check if rating already submitted for this session
    const ratedSessions = JSON.parse(localStorage.getItem('ratedSessions') || '[]');
    if (ratedSessions.includes(sessionId)) {
      console.log('Rating already submitted for this session');
      return;
    }

    // Create overlay
    const overlay = document.createElement('div');
    overlay.id = 'rating-overlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10001;
    `;

    // Create popup
    const popup = document.createElement('div');
    popup.style.cssText = `
      background: white;
      border-radius: 12px;
      padding: 30px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    `;

    let selectedRating = 0;

    popup.innerHTML = `
      <h3 style="margin: 0 0 8px 0; font-size: 20px; color: #333;">Come valuti il supporto?</h3>
      <p style="margin: 0 0 20px 0; font-size: 14px; color: #666;">Il tuo feedback ci aiuta a migliorare</p>

      <div id="stars-container" style="display: flex; gap: 8px; justify-content: center; margin-bottom: 20px;">
        ${[1,2,3,4,5].map(num => `
          <span class="rating-star" data-rating="${num}" style="
            font-size: 40px;
            cursor: pointer;
            color: #ddd;
            transition: all 0.2s;
          ">‚≠ê</span>
        `).join('')}
      </div>

      <textarea id="rating-comment" placeholder="Commento opzionale..." style="
        width: 100%;
        min-height: 80px;
        padding: 12px;
        border: 1px solid #ddd;
        border-radius: 8px;
        font-family: inherit;
        font-size: 14px;
        resize: vertical;
        margin-bottom: 20px;
      "></textarea>

      <div style="display: flex; gap: 10px;">
        <button id="rating-skip" style="
          flex: 1;
          padding: 12px;
          border: 1px solid #ddd;
          background: white;
          border-radius: 8px;
          cursor: pointer;
          font-size: 14px;
        ">Salta</button>
        <button id="rating-submit" disabled style="
          flex: 1;
          padding: 12px;
          background: #007bff;
          color: white;
          border: none;
          border-radius: 8px;
          cursor: pointer;
          font-size: 14px;
          opacity: 0.5;
        ">Invia</button>
      </div>
    `;

    overlay.appendChild(popup);
    document.body.appendChild(overlay);

    // Star interaction
    const stars = popup.querySelectorAll('.rating-star');
    const submitBtn = popup.querySelector('#rating-submit');

    stars.forEach((star, index) => {
      star.addEventListener('mouseenter', () => {
        stars.forEach((s, i) => {
          s.style.color = i <= index ? '#ffc107' : '#ddd';
          s.style.transform = i <= index ? 'scale(1.1)' : 'scale(1)';
        });
      });

      star.addEventListener('mouseleave', () => {
        stars.forEach((s, i) => {
          s.style.color = i < selectedRating ? '#ffc107' : '#ddd';
          s.style.transform = 'scale(1)';
        });
      });

      star.addEventListener('click', () => {
        selectedRating = index + 1;
        stars.forEach((s, i) => {
          s.style.color = i < selectedRating ? '#ffc107' : '#ddd';
        });
        submitBtn.disabled = false;
        submitBtn.style.opacity = '1';
      });
    });

    // Submit rating
    submitBtn.addEventListener('click', async () => {
      if (selectedRating === 0) return;

      const comment = popup.querySelector('#rating-comment').value.trim();

      try {
        submitBtn.disabled = true;
        submitBtn.textContent = 'Invio...';

        const response = await fetch(`${BACKEND_URL}/api/chat/sessions/${sessionId}/rating`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ rating: selectedRating, comment: comment || null }),
        });

        if (response.ok) {
          // Save to localStorage to prevent duplicate ratings
          ratedSessions.push(sessionId);
          localStorage.setItem('ratedSessions', JSON.stringify(ratedSessions));

          // Show thank you message
          popup.innerHTML = `
            <div style="text-align: center;">
              <div style="font-size: 60px; margin-bottom: 10px;">‚úÖ</div>
              <h3 style="margin: 0 0 8px 0; color: #333;">Grazie per il feedback!</h3>
              <p style="margin: 0; color: #666; font-size: 14px;">Il tuo parere ci aiuta a migliorare</p>
            </div>
          `;

          setTimeout(() => {
            overlay.remove();
          }, 2000);

          console.log(`‚úÖ P1.2: Rating ${selectedRating}‚≠ê submitted for session ${sessionId}`);
        } else {
          throw new Error('Failed to submit rating');
        }
      } catch (error) {
        console.error('Rating submission error:', error);
        alert('Errore durante l\'invio del rating. Riprova.');
        submitBtn.disabled = false;
        submitBtn.textContent = 'Invia';
      }
    });

    // Skip rating
    popup.querySelector('#rating-skip').addEventListener('click', () => {
      overlay.remove();
      console.log('Rating skipped');
    });
  }

  // Inactivity timeout functions
  function resetInactivityTimer() {
    lastUserActivity = Date.now();
    inactivityWarningShown = false;
  }

  function startInactivityCheck() {
    // Only start if in operator mode
    if (!isOperatorMode) return;

    // Clear existing interval if any
    if (inactivityCheckInterval) {
      clearInterval(inactivityCheckInterval);
    }

    // Check every 30 seconds
    inactivityCheckInterval = setInterval(checkInactivity, 30000);
    console.log('‚è±Ô∏è  Inactivity check started');
  }

  function stopInactivityCheck() {
    if (inactivityCheckInterval) {
      clearInterval(inactivityCheckInterval);
      inactivityCheckInterval = null;
      inactivityWarningShown = false;
      console.log('‚è±Ô∏è  Inactivity check stopped');
    }
  }

  function checkInactivity() {
    const now = Date.now();
    const inactiveTime = now - lastUserActivity;

    // Final warning - 5 minutes (notify operator)
    if (inactiveTime >= INACTIVITY_FINAL_TIME) {
      // Notify operator that user is truly inactive
      if (socket && socket.connected && sessionId) {
        socket.emit('user_inactive_final', {
          sessionId,
          inactiveTime: Math.floor(inactiveTime / 1000),
          message: 'Utente inattivo da 5 minuti'
        });
      }
      stopInactivityCheck();
      return;
    }

    // First warning - 3 minutes (show interactive prompt)
    if (inactiveTime >= INACTIVITY_WARNING_TIME && !inactivityWarningShown) {
      addMessage(
        '‚è±Ô∏è Sei ancora l√¨? La chat verr√† considerata inattiva tra 2 minuti.',
        'system'
      );

      // Show smart actions for user choice
      showSmartActions([
        {
          icon: 'üü¢',
          text: 'S√¨, sono qui',
          description: 'Continua con operatore',
          type: 'primary',
          action: 'confirm_presence'
        },
        {
          icon: 'ü§ñ',
          text: 'Continua con AI',
          description: 'Torna all\'assistente automatico',
          type: 'secondary',
          action: 'switch_to_ai'
        }
      ]);

      inactivityWarningShown = true;
    }
  }

  // ‚úÖ UPDATED: New API flow - Create session first, then send messages
  async function sendMessage(messageText) {
    const message = messageText || input.value.trim();
    if (!message) return;

    // Check if offline - queue message
    if (!isOnline || !navigator.onLine) {
      console.log('üî¥ Offline: Queueing message');
      queueMessage(message);
      input.value = '';
      input.style.height = 'auto';
      addMessage('üíæ Messaggio salvato. Verr√† inviato quando torni online.', 'system');
      return;
    }

    // Reset inactivity timer on user message
    resetInactivityTimer();

    // Rimuovi welcome se presente
    const welcome = messagesContainer.querySelector('.chat-welcome');
    if (welcome) welcome.remove();

    // Rimuovi smart actions precedenti se presenti
    const existingActions = document.querySelector('.smart-actions-container');
    if (existingActions) existingActions.remove();

    // Non mostrare i comandi interni come messaggi utente
    const isInternalCommand = message === 'request_operator' ||
                              message === 'continua con assistente AI' ||
                              message === 'continue_chat' ||
                              message === 'end_chat' ||
                              message === 'apri ticket';

    // BUG #9 FIX: Generate temporary ID for optimistic UI
    const tempId = !isInternalCommand ? `temp_${Date.now()}` : null;

    // Aggiungi messaggio utente (solo se non √® comando interno)
    if (!isInternalCommand) {
      addMessage(message, 'user', null, null, tempId);
    }

    // Reset input
    input.value = '';
    input.style.height = 'auto';

    // Disabilita input durante invio
    setInputState(false);
    showTyping();

    const loader = showLoadingIndicator('Invio in corso...');

    try {
      // ‚úÖ STEP 1: Create session if we don't have one
      if (!sessionId) {
        console.log('üìù Creating new chat session...');
        const sessionResponse = await fetch(`${BACKEND_URL}/api/chat/session`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            userName: 'Guest',
            userAgent: navigator.userAgent
          })
        });

        const sessionData = await sessionResponse.json();

        if (!sessionResponse.ok || !sessionData.data || !sessionData.data.id) {
          throw new Error('Failed to create session');
        }

        sessionId = sessionData.data.id;
        saveSessionId(sessionId);
        console.log('‚úÖ Session created:', sessionId);

        // Initialize Socket.IO connection
        initializeSocketIO();

        // P2.6: Unlock audio on first interaction
        unlockAudio();

        // P2.7: Request notification permission after first message
        requestNotificationPermission();
      }

      // ‚úÖ STEP 2: Send message to session OR request operator
      if (message === 'request_operator') {
        // Request operator endpoint
        const operatorResponse = await fetch(`${BACKEND_URL}/api/chat/session/${sessionId}/request-operator`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          }
        });

        const operatorData = await operatorResponse.json();

        if (!operatorResponse.ok || operatorData.error) {
          throw new Error(operatorData.error?.message || 'Failed to request operator');
        }

        // Handle operator response
        if (operatorData.data?.operatorAvailable === false) {
          // No operators available
          addMessage(operatorData.data.message || 'Nessun operatore disponibile al momento.', 'bot');

          // ‚úÖ FIX P0.3: Show smart actions to open ticket or continue with AI
          showSmartActions([
            {
              icon: 'üìù',
              text: 'Apri Ticket',
              description: 'Lascia un messaggio, ti ricontatteremo',
              action: 'request_ticket',
              type: 'primary'
            },
            {
              icon: 'ü§ñ',
              text: 'Continua con AI',
              description: 'Prova a chiedermi altro',
              action: 'continue_ai',
              type: 'secondary'
            }
          ]);
        } else if (operatorData.data?.operatorAvailable === true && operatorData.data?.status === 'WAITING') {
          // NEW: Waiting for operator to accept
          console.log(`‚è≥ Waiting for operator acceptance...`);
          showWaitingForOperator();
        } else if (operatorData.data?.operatorAvailable === true) {
          // Operator assigned successfully (old flow - backwards compatibility)
          console.log(`‚úÖ Operator assigned - waiting for connection message`);
        } else {
          // In queue (shouldn't happen with current backend logic)
          addMessage('Sei in coda. Un operatore ti risponder√† appena possibile.', 'system');
        }
      } else {
        // Normal message to AI
        const messageResponse = await fetch(`${BACKEND_URL}/api/chat/session/${sessionId}/message`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            message: message
          })
        });

        const data = await messageResponse.json();

        if (!messageResponse.ok || data.error) {
          // Handle rate limiting (429)
          if (messageResponse.status === 429) {
            const resetIn = data.error?.resetIn || 60;
            addMessage(`‚ö†Ô∏è ${data.error?.message || 'Rallenta, per favore. Troppi messaggi inviati.'} Riprova tra ${resetIn} secondi.`, 'system');
            return;
          }
          throw new Error(data.error?.message || 'Failed to send message');
        }

        // Aggiungi risposta AI se presente
        if (data.data?.aiResponse && data.data.aiResponse.content) {
          addMessage(data.data.aiResponse.content, 'bot');

          // Se l'AI suggerisce operatore, mostra smart action
          if (data.data.aiResponse.suggestOperator) {
            console.log('üí° AI suggests operator assistance');
            showSmartActions([
              {
                icon: 'üë§',
                text: 'Parla con un operatore',
                action: 'request_operator',
                type: 'primary'
              },
              {
                icon: 'ü§ñ',
                text: 'Continua con AI',
                action: 'continue_ai',
                type: 'secondary'
              }
            ]);
          }
        } else if (data.data?.withOperator) {
          // Sei in chat con operatore - il messaggio √® stato inviato
          console.log(`‚úÖ Message sent to operator: ${data.data.operatorName}`);

          // Assicurati che isOperatorMode sia true e header sia aggiornato
          if (!isOperatorMode) {
            isOperatorMode = true;
            updateHeaderForOperatorMode();
          }
        }
      }

    } catch (error) {
      console.error('‚ùå Chat Error:', error);

      // BUG #9 FIX: Remove temporary user message on error (rollback optimistic UI)
      if (tempId) {
        removeMessage(tempId);
      }

      addMessage('Mi dispiace, c\'√® stato un problema. Riprova o contatta üìß info@lucinedinatale.it', 'bot');
    } finally {
      hideTyping();
      hideLoadingIndicator(loader);
      setInputState(true);
      input.focus();
    }
  }

  // BUG #9 FIX: Support temporary message IDs for optimistic UI with rollback
  function addMessage(text, sender, operatorName = null, attachment = null, tempId = null) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message ${sender}`;

    // BUG #9 FIX: Store temp ID as data attribute for removal if needed
    if (tempId) {
      messageDiv.setAttribute('data-temp-id', tempId);
    }

    const bubbleDiv = document.createElement('div');
    bubbleDiv.className = 'message-bubble';

    // P0.1: Display file attachment if present
    if (attachment && attachment.url) {
      const attachmentDiv = document.createElement('div');
      attachmentDiv.style.cssText = 'margin-bottom: 8px;';

      if (attachment.resourceType === 'image') {
        // Display image
        const img = document.createElement('img');
        img.src = attachment.url;
        img.alt = attachment.originalName || 'Image';
        img.style.cssText = 'max-width: 100%; height: auto; border-radius: 8px; max-height: 200px; object-fit: contain; cursor: pointer;';
        img.onclick = () => window.open(attachment.url, '_blank');
        attachmentDiv.appendChild(img);
      } else {
        // Display file card
        const fileCard = document.createElement('a');
        fileCard.href = attachment.url;
        fileCard.target = '_blank';
        fileCard.rel = 'noopener noreferrer';
        fileCard.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; text-decoration: none; color: inherit; transition: background 0.2s;';
        fileCard.onmouseover = () => fileCard.style.background = 'rgba(255,255,255,0.2)';
        fileCard.onmouseout = () => fileCard.style.background = 'rgba(255,255,255,0.1)';

        const icon = document.createElement('span');
        icon.style.cssText = 'font-size: 24px;';
        const mimetype = attachment.mimetype || '';
        if (mimetype.includes('pdf')) icon.textContent = 'üìÑ';
        else if (mimetype.includes('word')) icon.textContent = 'üìù';
        else if (mimetype.includes('excel') || mimetype.includes('spreadsheet')) icon.textContent = 'üìä';
        else if (mimetype.includes('zip') || mimetype.includes('rar')) icon.textContent = 'üì¶';
        else icon.textContent = 'üìé';

        const details = document.createElement('div');
        details.style.cssText = 'flex: 1; min-width: 0;';
        const filename = document.createElement('div');
        filename.textContent = attachment.originalName || 'File';
        filename.style.cssText = 'font-weight: 500; font-size: 14px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;';
        const filesize = document.createElement('div');
        filesize.textContent = attachment.size ? `${(attachment.size / 1024).toFixed(1)} KB` : '';
        filesize.style.cssText = 'font-size: 12px; opacity: 0.7;';
        details.appendChild(filename);
        details.appendChild(filesize);

        const downloadIcon = document.createElement('span');
        downloadIcon.textContent = '‚¨á';
        downloadIcon.style.cssText = 'font-size: 18px;';

        fileCard.appendChild(icon);
        fileCard.appendChild(details);
        fileCard.appendChild(downloadIcon);
        attachmentDiv.appendChild(fileCard);
      }

      bubbleDiv.appendChild(attachmentDiv);
    }

    // Processa il testo per rendere i link cliccabili
    let processedText = escapeHtml(text);

    // Markdown: Bold (**text**) e Italic (*text* o _text_)
    processedText = processedText.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    processedText = processedText.replace(/\*([^*]+)\*/g, '<em>$1</em>');
    processedText = processedText.replace(/_([^_]+)_/g, '<em>$1</em>');

    // Prima processa i link markdown [testo](url)
    processedText = processedText.replace(
      /\[([^\]]+)\]\((https?:\/\/[^)]+)\)/g,
      (match, linkText, url) => {
        if (url.includes('lucinedinatale.it/products/')) {
          return '<a href="' + url + '" target="_blank" class="chat-link product-link">üé´ ' + linkText + '</a>';
        } else if (url.includes('lucinedinatale.it/cart')) {
          return '<a href="' + url + '" target="_blank" class="chat-link cart-link">üõí ' + linkText + '</a>';
        } else if (url.includes('wa.me/')) {
          return '<a href="' + url + '" target="_blank" class="chat-link whatsapp-link">üì± ' + linkText + '</a>';
        } else {
          return '<a href="' + url + '" target="_blank" class="chat-link">' + linkText + '</a>';
        }
      }
    );

    // Poi processa le URL nude
    processedText = processedText.replace(
      /(?<!href=")(?<!href=')(https?:\/\/lucinedinatale\.it\/products\/[^\s<]+)/g,
      '<a href="$1" target="_blank" class="chat-link product-link">üé´ Prenota biglietti</a>'
    );

    processedText = processedText.replace(
      /(?<!href=")(?<!href=')(https?:\/\/lucinedinatale\.it\/cart[^\s<]*)/g,
      '<a href="$1" target="_blank" class="chat-link cart-link">üõí Vai al carrello</a>'
    );

    // Email links
    processedText = processedText.replace(
      /(?<!href=")(?<!href=')(info@lucinedinatale\.it)/g,
      '<a href="mailto:$1" class="chat-link email-link">üìß $1</a>'
    );

    // WhatsApp links
    processedText = processedText.replace(
      /(?<!href=")(?<!href=')(https?:\/\/wa\.me\/[^\s<]+)/g,
      '<a href="$1" target="_blank" class="chat-link whatsapp-link">üì± Contatta WhatsApp</a>'
    );

    // Altri link generici
    processedText = processedText.replace(
      /(?<!href=")(?<!href=')(?<!class="chat-link[^"]*">)(https?:\/\/[^\s<]+)/g,
      '<a href="$1" target="_blank" class="chat-link">üîó Apri link</a>'
    );

    // Converte line breaks
    processedText = processedText.replace(/\n\n/g, '<br><br>');
    processedText = processedText.replace(/\n/g, '<br>');

    bubbleDiv.innerHTML = processedText;

    // Add operator name badge ABOVE message bubble (not inline)
    if (sender === 'operator' && operatorName) {
      const badgeDiv = document.createElement('div');
      badgeDiv.className = 'operator-badge';
      badgeDiv.textContent = operatorName;
      badgeDiv.style.cssText = `
        font-size: 11px;
        color: #666;
        margin-bottom: 4px;
        font-weight: 500;
      `;
      messageDiv.appendChild(badgeDiv);
    }

    messageDiv.appendChild(bubbleDiv);
    messagesContainer.appendChild(messageDiv);

    // Scroll to bottom
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }

  // BUG #9 FIX: Remove message by temporary ID (for rollback on error)
  function removeMessage(tempId) {
    const messageDiv = messagesContainer.querySelector(`[data-temp-id="${tempId}"]`);
    if (messageDiv) {
      messageDiv.remove();
      console.log(`üóëÔ∏è Removed temporary message: ${tempId}`);
    }
  }

  function showSmartActions(actions) {
    // Rimuovi smart actions precedenti
    const existingActions = document.querySelector('.smart-actions-container');
    if (existingActions) {
      existingActions.remove();
    }

    if (!actions || !Array.isArray(actions) || actions.length === 0) {
      console.warn('‚ö†Ô∏è showSmartActions called with invalid data:', actions);
      return;
    }

    const actionsContainer = document.createElement('div');
    actionsContainer.className = 'smart-actions-container';

    const actionsGrid = document.createElement('div');
    actionsGrid.className = 'smart-actions-grid';

    actions.forEach(action => {
      if (!action || typeof action !== 'object' || !action.text) {
        console.error('‚ùå Invalid action object:', action);
        return;
      }

      const icon = action.icon || 'üìå';
      const text = action.text;
      const description = action.description || '';
      const type = action.type || 'secondary';

      const actionButton = document.createElement('button');
      actionButton.className = `smart-action-button ${type}`;

      actionButton.innerHTML = `
        <div class="action-icon">${icon}</div>
        <div class="action-content">
          <div class="action-text">${text}</div>
          ${description ? `<div class="action-description">${description}</div>` : ''}
        </div>
      `;

      if (action.disabled === true) {
        actionButton.disabled = true;
        actionButton.style.opacity = '0.8';
        actionButton.style.cursor = 'default';
      }

      if (!action.disabled && !action.action && !action.url) {
        actionButton.disabled = true;
        actionButton.style.opacity = '0.6';
      }

      actionButton.addEventListener('click', () => {
        // FIX: Remove ALL smart action containers immediately on click
        const removeAllActionContainers = () => {
          document.querySelectorAll('.smart-actions-container').forEach(el => el.remove());
        };

        if (action.url) {
          window.open(action.url, '_blank');
          removeAllActionContainers();
        } else if (action.action === 'request_operator') {
          sendMessage('request_operator');
          removeAllActionContainers();
        } else if (action.action === 'continue_ai') {
          sendMessage('continua con assistente AI');
          removeAllActionContainers();
        } else if (action.action === 'continue_chat') {
          sendMessage('continue_chat');
          removeAllActionContainers();
        } else if (action.action === 'end_chat') {
          sendMessage('end_chat');
          removeAllActionContainers();
        } else if (action.action === 'request_ticket') {
          // ‚úÖ FIX P0.4: Show ticket form instead of sending message
          removeAllActionContainers();
          showTicketForm();
        } else if (action.action === 'resume_chat') {
          // NEW: Resume existing chat session
          removeAllActionContainers();
          resumeExistingChat();
        } else if (action.action === 'start_new_chat') {
          // NEW: Start fresh new chat
          removeAllActionContainers();
          startNewChat();
        } else if (action.action === 'confirm_presence') {
          // NEW: User confirms they are still present
          removeAllActionContainers();
          resetInactivityTimer();
          addMessage('‚úÖ Perfetto! Continuo ad aspettarti.', 'system');
          // Notify operator user is back
          if (socket && socket.connected && sessionId) {
            socket.emit('user_confirmed_presence', {
              sessionId,
              timestamp: new Date().toISOString()
            });
          }
        } else if (action.action === 'switch_to_ai') {
          // NEW: User wants to switch back to AI
          removeAllActionContainers();
          stopInactivityCheck();
          isOperatorMode = false;
          // Reset header
          const chatTitle = document.querySelector('.chat-title');
          if (chatTitle) {
            chatTitle.textContent = 'LUCY - ASSISTENTE VIRTUALE';
            chatTitle.style.color = '';
          }
          addMessage('ü§ñ Perfetto! Torno in modalit√† assistente AI. Come posso aiutarti?', 'bot');
          // Notify operator user switched to AI
          if (socket && socket.connected && sessionId) {
            socket.emit('user_switched_to_ai', {
              sessionId,
              timestamp: new Date().toISOString()
            });
          }
        } else if (action.action === 'reopen_chat') {
          // ISSUE #14: Reopen recently closed chat (<5 min)
          const reopenSessionId = action.data?.sessionId;
          const closedAt = action.data?.closedAt;

          // Client-side check: verify still within 5-minute window
          if (closedAt && (Date.now() - closedAt) > 5 * 60 * 1000) {
            addMessage('‚ö†Ô∏è Troppo tempo √® passato dalla chiusura. Inizia una nuova chat.', 'system');
            removeAllActionContainers();
            return;
          }

          removeAllActionContainers();
          setInputState(false);

          console.log(`üîÑ Attempting to reopen session ${reopenSessionId}`);

          fetch(`${BACKEND_URL}/api/chat/session/${reopenSessionId}/reopen`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          })
            .then(res => res.json())
            .then(data => {
              if (data.success) {
                console.log('‚úÖ Chat reopened successfully:', data);

                // Restore session state
                sessionId = reopenSessionId;
                isOperatorMode = true;

                // Add system message if provided
                if (data.data.message) {
                  addMessage(data.data.message.content, 'system');
                }

                // Update UI to operator mode
                updateHeaderForOperatorMode();
                setInputState(true);
                input.placeholder = `Scrivi a ${data.data.operatorName || 'operatore'}...`;

                console.log(`‚úÖ Session ${sessionId} reopened, WITH_OPERATOR mode active`);
              } else {
                throw new Error(data.error?.message || 'Failed to reopen chat');
              }
            })
            .catch(err => {
              console.error('‚ùå Failed to reopen chat:', err);

              // Check if error code indicates window expired
              if (err.message?.includes('too long ago') || err.message?.includes('REOPEN_WINDOW_EXPIRED')) {
                addMessage('‚è±Ô∏è Troppo tempo √® passato dalla chiusura. Inizia una nuova chat.', 'system');
              } else {
                addMessage('‚ùå Impossibile riaprire la chat. Inizia una nuova conversazione.', 'system');
              }

              setInputState(true);
            });
        } else if (action.action === 'start_fresh_chat') {
          // SECURITY: Prevent fresh chat during active operator session
          if (isOperatorMode) {
            alert('Non puoi iniziare una nuova chat mentre sei connesso con un operatore. L\'operatore deve chiudere la chat prima.');
            removeAllActionContainers();
            return;
          }

          // NEW: Start completely fresh chat (after closure)
          removeAllActionContainers();
          chatMessages.innerHTML = '';
          displayedMessageIds.clear();
          isOperatorMode = false;
          // Reset header
          const chatTitle = document.querySelector('.chat-title');
          if (chatTitle) {
            chatTitle.textContent = 'LUCY - ASSISTENTE VIRTUALE';
            chatTitle.style.color = '';
          }
          // Re-enable input
          setInputState(true);
          input.placeholder = 'Scrivi un messaggio...';
          addMessage('üí¨ Nuova chat avviata. Come posso aiutarti?', 'bot');
        } else if (action.action === 'show_rating') {
          // NEW: Show rating popup for closed session
          removeAllActionContainers();
          const sessionId = action.data?.sessionId;
          if (sessionId) {
            showRatingPopup(sessionId);
          }
        } else if (action.action === 'close_widget') {
          // v2.3.7: FIX BUG #2 - Close widget action handler
          closePopup(); // Minimizza il widget
          removeAllActionContainers();
        } else {
          console.warn('‚ö†Ô∏è Unknown action:', action.action);
          removeAllActionContainers();
        }
      });

      actionsGrid.appendChild(actionButton);
    });

    actionsContainer.appendChild(actionsGrid);
    messagesContainer.appendChild(actionsContainer);

    // ‚úÖ DEBUG: Confirm buttons were added
    console.log(`‚úÖ Smart actions added to DOM: ${actions.length} buttons`);
    console.log('üìç Actions container in DOM:', messagesContainer.contains(actionsContainer));

    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }

  function showTyping() {
    typingIndicator.classList.add('show');
  }

  function hideTyping() {
    typingIndicator.classList.remove('show');
  }

  function setInputState(enabled) {
    input.disabled = !enabled;
    sendBtn.disabled = !enabled;
  }

  // Network Quality Detection Functions
  function showNetworkIndicator(status) {
    // Remove existing indicator
    const existingIndicator = document.querySelector('.network-indicator');
    if (existingIndicator) {
      existingIndicator.remove();
    }

    const indicators = {
      offline: { icon: 'üî¥', text: 'Offline', color: '#dc2626' },
      reconnecting: { icon: 'üü°', text: 'Riconnessione...', color: '#f59e0b' },
      online: { icon: 'üü¢', text: 'Online', color: '#16a34a' }
    };

    const indicator = indicators[status];
    if (!indicator) return;

    const indicatorEl = document.createElement('div');
    indicatorEl.className = 'network-indicator';
    indicatorEl.style.cssText = `
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: ${indicator.color}15;
      border-left: 3px solid ${indicator.color};
      font-size: 13px;
      color: ${indicator.color};
      font-weight: 500;
    `;
    indicatorEl.innerHTML = `<span>${indicator.icon}</span><span>${indicator.text}</span>`;

    // Insert at top of messages container
    const chatMessages = document.getElementById('chatMessages');
    chatMessages.insertBefore(indicatorEl, chatMessages.firstChild);

    // Auto-hide "online" after 3 seconds
    if (status === 'online') {
      setTimeout(() => {
        indicatorEl.style.transition = 'opacity 0.5s';
        indicatorEl.style.opacity = '0';
        setTimeout(() => indicatorEl.remove(), 500);
      }, 3000);
    }
  }

  function hideNetworkIndicator() {
    const indicator = document.querySelector('.network-indicator');
    if (indicator) {
      indicator.remove();
    }
  }

  function handleOffline() {
    isOnline = false;
    console.log('üî¥ Network: OFFLINE');
    showNetworkIndicator('offline');

    // Disable input
    setInputState(false);
    input.placeholder = 'üî¥ Nessuna connessione...';
  }

  function handleOnline() {
    isOnline = true;
    reconnectAttempts = 0;
    console.log('üü¢ Network: ONLINE');
    showNetworkIndicator('online');

    // Re-enable input if not in operator mode
    if (!isOperatorMode) {
      setInputState(true);
      input.placeholder = 'Scrivi un messaggio...';
    }

    // Send queued messages
    if (messageQueue.length > 0) {
      console.log(`üì§ Sending ${messageQueue.length} queued messages...`);
      sendQueuedMessages();
    }
  }

  function handleReconnecting() {
    reconnectAttempts++;
    console.log(`üü° Reconnecting... (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
    showNetworkIndicator('reconnecting');

    if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
      handleOffline();
    }
  }

  function queueMessage(message) {
    messageQueue.push({
      content: message,
      timestamp: Date.now()
    });
    console.log(`üíæ Message queued (${messageQueue.length} in queue)`);

    // Save queue to localStorage
    try {
      localStorage.setItem('lucine_message_queue', JSON.stringify(messageQueue));
    } catch (e) {
      console.error('Failed to save message queue:', e);
    }
  }

  async function sendQueuedMessages() {
    if (messageQueue.length === 0) return;

    const queue = [...messageQueue];
    messageQueue = [];

    // Clear localStorage queue
    try {
      localStorage.removeItem('lucine_message_queue');
    } catch (e) {
      console.error('Failed to clear message queue:', e);
    }

    // Send each message
    for (const queuedMsg of queue) {
      try {
        await sendMessage(queuedMsg.content);
        console.log(`‚úÖ Queued message sent: ${queuedMsg.content.substring(0, 30)}...`);
      } catch (error) {
        console.error('Failed to send queued message:', error);
        // Re-queue if failed
        messageQueue.push(queuedMsg);
      }
    }

    // If some messages failed, save them back
    if (messageQueue.length > 0) {
      try {
        localStorage.setItem('lucine_message_queue', JSON.stringify(messageQueue));
      } catch (e) {
        console.error('Failed to save message queue:', e);
      }
    }
  }

  // Load queued messages from localStorage on init
  try {
    const savedQueue = localStorage.getItem('lucine_message_queue');
    if (savedQueue) {
      messageQueue = JSON.parse(savedQueue);
      console.log(`üì• Loaded ${messageQueue.length} queued messages from storage`);
    }
  } catch (e) {
    console.error('Failed to load message queue:', e);
  }

  function showWaitingForOperator() {
    // Remove any existing waiting UI
    hideWaitingForOperator();

    // Disable input while waiting
    setInputState(false);
    input.placeholder = '‚è≥ In attesa di un operatore...';

    // Create waiting UI with cancel button
    const waitingContainer = document.createElement('div');
    waitingContainer.id = 'waiting-operator-container';
    waitingContainer.className = 'smart-actions-container';

    waitingContainer.innerHTML = `
      <div class="waiting-operator-message">
        <div class="waiting-icon">‚è≥</div>
        <div class="waiting-text">
          <strong>In attesa di un operatore...</strong>
          <p>La tua richiesta √® stata inviata. Un operatore risponder√† appena possibile.</p>
        </div>
      </div>
      <button id="cancel-operator-request-btn" class="smart-action-button secondary" style="width: 100%; margin-top: 10px;">
        <div class="action-icon">‚úñÔ∏è</div>
        <div class="action-content">
          <div class="action-text">Annulla Richiesta</div>
          <div class="action-description">Torna all'assistente AI</div>
        </div>
      </button>
    `;

    chatMessages.appendChild(waitingContainer);
    chatMessages.scrollTop = chatMessages.scrollHeight;

    // Add cancel button event listener
    const cancelBtn = document.getElementById('cancel-operator-request-btn');
    if (cancelBtn) {
      cancelBtn.addEventListener('click', async () => {
        await cancelOperatorRequest();
      });
    }
  }

  function hideWaitingForOperator() {
    console.log('üîç Attempting to hide waiting operator UI...');
    const waitingContainer = document.getElementById('waiting-operator-container');
    if (waitingContainer) {
      waitingContainer.remove();
      console.log('‚úÖ Waiting operator UI removed successfully');
    } else {
      console.log('‚ÑπÔ∏è No waiting operator UI found (already removed or never shown)');
    }

    // Defensive: Also remove by class in case ID was lost
    const waitingElements = document.querySelectorAll('.waiting-operator-message');
    if (waitingElements.length > 0) {
      waitingElements.forEach(el => el.closest('.smart-actions-container')?.remove());
      console.log(`üßπ Cleaned up ${waitingElements.length} orphaned waiting UI elements`);
    }
  }

  async function cancelOperatorRequest() {
    if (!sessionId) return;

    try {
      const response = await fetch(`${BACKEND_URL}/api/chat/session/${sessionId}/cancel-operator-request`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        }
      });

      const data = await response.json();

      if (!response.ok || data.error) {
        // FIX: If 400 error, operator may have already joined - hide waiting UI gracefully
        if (response.status === 400) {
          console.log('‚ÑπÔ∏è Cannot cancel: operator may have already joined');
          hideWaitingForOperator();
          addMessage('Un operatore si √® appena unito alla chat!', 'system');
          return;
        }
        throw new Error(data.error?.message || 'Failed to cancel operator request');
      }

      console.log('üö´ Operator request cancelled successfully');
      hideWaitingForOperator();

      // Re-enable input
      setInputState(true);
      input.placeholder = 'Scrivi un messaggio...';

      // Show confirmation message
      addMessage(data.data?.message || 'Richiesta annullata. Puoi continuare con l\'assistente AI.', 'system');

    } catch (error) {
      console.error('Failed to cancel operator request:', error);
      alert('Errore durante l\'annullamento della richiesta');
    }
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function showLoadingIndicator(message = 'Caricamento...') {
    const existingLoader = messagesContainer.querySelector('.chat-loading-indicator');
    if (existingLoader) {
      existingLoader.remove();
    }

    const loader = document.createElement('div');
    loader.className = 'chat-loading-indicator';
    loader.innerHTML = `
      <div class="loading-content">
        <div class="spinner"></div>
        <span class="loading-text">${message}</span>
      </div>
    `;
    messagesContainer.appendChild(loader);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    return loader;
  }

  function hideLoadingIndicator(loader) {
    if (loader && loader.parentNode) {
      loader.parentNode.removeChild(loader);
    }
  }

  function updateHeaderForOperatorMode() {
    const chatTitle = document.querySelector('.chat-title');
    if (chatTitle) {
      chatTitle.innerHTML = 'üü¢ CHAT DAL VIVO - OPERATORE';
      chatTitle.style.color = '#10B981';
    }

    // v2.3.5: ISSUE #10 - Show "Return to AI" button
    const returnBtn = document.getElementById('returnToAIBtn');
    if (returnBtn) {
      returnBtn.style.display = 'block';
    }
  }

  // v2.3.5: ISSUE #10 - User returns to AI from operator chat
  window.returnToAI = async function() {
    if (!sessionId) {
      console.error('‚ùå No session ID for return to AI');
      return;
    }

    if (!confirm('Vuoi tornare all\'assistente AI? L\'operatore verr√† disconnesso dalla chat.')) {
      return;
    }

    try {
      const response = await fetch(`${BACKEND_URL}/api/chat/session/${sessionId}/return-to-ai`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      const data = await response.json();

      if (response.ok && data.success) {
        console.log('‚úÖ Returned to AI successfully');

        // Switch to AI mode
        isOperatorMode = false;
        stopInactivityCheck();

        // Hide return button
        const returnBtn = document.getElementById('returnToAIBtn');
        if (returnBtn) {
          returnBtn.style.display = 'none';
        }

        // Reset header
        const chatTitle = document.querySelector('.chat-title');
        if (chatTitle) {
          chatTitle.textContent = 'LUCY - ASSISTENTE VIRTUALE';
          chatTitle.style.color = '';
        }

        // Re-enable input for AI
        setInputState(true);
        input.placeholder = 'Scrivi un messaggio...';

        // Add confirmation message
        addMessage('‚úÖ Sei tornato all\'assistente AI. Come posso aiutarti?', 'bot');
      } else {
        throw new Error(data.error?.message || 'Errore durante il ritorno all\'AI');
      }
    } catch (error) {
      console.error('‚ùå Return to AI error:', error);
      alert('Errore durante il ritorno all\'assistente AI. Riprova.');
    }
  };

  // v2.3.7: BUG #1 - End conversation and start fresh
  window.endConversation = async function() {
    // Confirm with user
    if (!confirm('Vuoi terminare questa conversazione e iniziare da zero?\n\nTutta la cronologia della chat verr√† rimossa.')) {
      return;
    }

    try {
      // If there's a session, notify backend
      if (sessionId) {
        const response = await fetch(`${BACKEND_URL}/api/chat/session/${sessionId}/end-conversation`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        const data = await response.json();

        if (response.ok && data.success) {
          console.log('‚úÖ Conversation ended successfully');
        } else {
          console.warn('‚ö†Ô∏è Error ending conversation:', data.error?.message);
          // Continue anyway to reset local state
        }
      }

      // Clear session completely
      clearSessionStorage(); // Clears both SESSION_STORAGE_KEY and SESSION_EXPIRY_KEY
      sessionId = null;
      sessionValidated = false;
      isOperatorMode = false;
      userName = null;

      // Stop all timers
      stopInactivityCheck();

      // Hide operator-specific UI
      const returnBtn = document.getElementById('returnToAIBtn');
      if (returnBtn) {
        returnBtn.style.display = 'none';
      }

      // Reset header
      const chatTitle = document.querySelector('.chat-title');
      if (chatTitle) {
        chatTitle.textContent = 'LUCY - ASSISTENTE VIRTUALE';
        chatTitle.style.color = '';
      }

      // Clear all messages
      messagesContainer.innerHTML = '';

      // Reset input
      setInputState(true);
      input.placeholder = 'Scrivi un messaggio...';
      input.value = '';

      // Show fresh welcome message
      addMessage('üëã Ciao! Sono Lucy, la tua assistente virtuale. Come posso aiutarti oggi?', 'bot');

      console.log('üîÑ Conversation reset - ready for new session');
    } catch (error) {
      console.error('‚ùå End conversation error:', error);
      alert('Errore durante la terminazione. La chat verr√† comunque resettata.');

      // Force reset anyway
      clearSessionStorage();
      sessionId = null;
      sessionValidated = false;
      isOperatorMode = false;
      messagesContainer.innerHTML = '';
      addMessage('üëã Ciao! Sono Lucy, la tua assistente virtuale. Come posso aiutarti oggi?', 'bot');
    }
  };

  // NEW: Show resume prompt when WITH_OPERATOR session found
  function showResumePrompt(operatorName) {
    // Add system message
    const operatorText = operatorName ? ` con ${operatorName}` : '';
    addMessage(`Hai una chat in corso${operatorText}. Vuoi riprenderla?`, 'system');

    // Show action buttons
    showSmartActions([
      {
        icon: 'üîÑ',
        text: 'Riprendi chat',
        description: 'Continua la conversazione',
        type: 'primary',
        action: 'resume_chat'
      },
      {
        icon: '‚ûï',
        text: 'Nuova chat',
        description: 'Inizia da zero',
        type: 'secondary',
        action: 'start_new_chat'
      }
    ]);

    // Show badge to notify user
    updateBadge(1);
  }

  // Resume the pending session
  async function resumeExistingChat() {
    if (!pendingResumeSession) {
      console.error('‚ùå No pending session to resume');
      return;
    }

    console.log('üîÑ Resuming session:', pendingResumeSession.sessionId);

    // Set sessionId and save to localStorage
    sessionId = pendingResumeSession.sessionId;
    saveSessionId(sessionId); // Save to localStorage
    pendingResumeSession = null;

    // Mark as operator mode
    isOperatorMode = true;
    updateHeaderForOperatorMode();

    // Load previous messages
    try {
      const response = await fetch(`${BACKEND_URL}/api/chat/session/${sessionId}`);
      const data = await response.json();
      const session = data.data || data;

      // CHECK: Is operator still online?
      if (session.status === 'WITH_OPERATOR' && !session.operatorOnline) {
        console.warn('‚ö†Ô∏è Operator is offline - showing recovery options');

        // Clear chat and show recovery message
        chatMessages.innerHTML = '';
        displayedMessageIds.clear();

        addMessage('L\'operatore precedentemente connesso non √® pi√π disponibile. Scegli come continuare:', 'system');

        // Show recovery options
        showSmartActions([
          {
            icon: 'üìã',
            text: 'Apri Ticket',
            description: 'Lascia un messaggio, ti ricontatteremo',
            action: 'request_ticket',
            type: 'primary'
          },
          {
            icon: 'ü§ñ',
            text: 'Continua con AI',
            description: 'Riprendi con assistente automatico',
            action: 'continue_ai',
            type: 'secondary'
          },
          {
            icon: 'üë§',
            text: 'Richiedi nuovo operatore',
            description: 'Attendi un operatore disponibile',
            action: 'request_operator',
            type: 'secondary'
          }
        ]);

        return; // Stop here - don't resume chat
      }

      // Clear chat and reload messages
      chatMessages.innerHTML = '';
      displayedMessageIds.clear();

      // Add messages from session
      if (session.messagesNew && Array.isArray(session.messagesNew)) {
        session.messagesNew.forEach(msg => {
          if (!displayedMessageIds.has(msg.id)) {
            displayedMessageIds.add(msg.id);
            const sender = msg.type === 'USER' ? 'user' :
                          msg.type === 'OPERATOR' ? 'operator' : 'bot';
            addMessage(msg.content, sender, msg.operatorName);
          }
        });
      }

      addMessage('‚úÖ Chat ripresa con successo!', 'system');

      // Join WebSocket room
      if (socket && socket.connected) {
        console.log('üîå Joining WebSocket room:', sessionId);
        socket.emit('join_chat', { sessionId });

        // Notify operator that user has resumed the chat
        socket.emit('user_resumed_chat', {
          sessionId,
          userName: session.userName || 'Utente',
          timestamp: new Date().toISOString()
        });
      } else {
        console.log('‚è≥ Socket not connected yet - will join on connect');
        // Socket will auto-join when it connects (socket.on('connect') handler)
      }

      // Start inactivity check for resumed chat
      startInactivityCheck();

    } catch (error) {
      console.error('‚ùå Error resuming chat:', error);
      addMessage('Errore durante il ripristino della chat.', 'system');
    }
  }

  // Start fresh new chat
  function startNewChat() {
    console.log('‚ûï Starting new chat - clearing old session');

    // Clear localStorage
    clearSessionStorage();
    sessionId = null;
    pendingResumeSession = null;
    sessionValidated = false;

    // Clear chat
    chatMessages.innerHTML = '';
    displayedMessageIds.clear();
    isOperatorMode = false;

    // Reset header
    const chatTitle = document.querySelector('.chat-title');
    if (chatTitle) {
      chatTitle.textContent = 'LUCY - ASSISTENTE VIRTUALE';
      chatTitle.style.color = '';
    }

    addMessage('üí¨ Nuova chat avviata. Come posso aiutarti?', 'bot');
  }

  // ‚úÖ UPDATED: Resume from ticket - Fixed endpoint
  async function resumeChatFromTicket(token) {
    try {
      console.log('üîó Resuming chat from ticket token...');

      const response = await fetch(`${BACKEND_URL}/api/tickets/resume/${token}`);
      const data = await response.json();

      if (!response.ok || data.error) {
        console.error('‚ùå Resume error:', data.message);
        addMessage(`‚ùå ${data.message || 'Token non valido o scaduto'}`, 'bot');
        return;
      }

      console.log('‚úÖ Chat resumed:', data);

      // Set sessionId from ticket
      sessionId = data.data?.sessionId;
      if (sessionId) {
        saveSessionId(sessionId);
      }

      // Open popup automatically
      openPopup();

      // Load previous messages from chatHistory
      if (data.data?.chatHistory) {
        try {
          const messages = JSON.parse(data.data.chatHistory);
          messages.forEach((msg) => {
            const sender = msg.type === 'user' ? 'user' :
                          msg.type === 'operator' ? 'operator' : 'ai' ? 'bot' : 'bot';
            addMessage(msg.content, sender);
          });
        } catch (e) {
          console.error('Error parsing chat history:', e);
        }
      }

      // Show welcome message
      addMessage('Conversazione ripristinata! Continua da dove avevi lasciato.', 'bot');

      // Initialize Socket.IO
      if (sessionId) {
        initializeSocketIO();
      }

    } catch (error) {
      console.error('‚ùå Failed to resume chat:', error);
      addMessage('‚ùå Errore nel riprendere la conversazione. Riprova pi√π tardi.', 'bot');
    }
  }

  // Esponi sendMessage globalmente
  window.sendMessage = sendMessage;

  // Show ticket form
  function showTicketForm() {
    // v2.3.4: Pre-fill name if we have it
    const nameValue = userName || '';

    const ticketHtml = `
      <div class="ticket-form" style="margin: 1rem 0; padding: 1rem; background: rgba(45, 45, 45, 0.8); border-radius: 12px; border: 1px solid rgba(255,255,255,0.2);">
        <h4 style="color: #f59e0b; margin-bottom: 1rem; font-size: 1.1rem;">üìù Lascia un messaggio</h4>
        <input type="text" id="ticketName" placeholder="Il tuo nome" value="${nameValue}" style="width: 100%; margin-bottom: 0.5rem; padding: 0.5rem; border: 1px solid #555; border-radius: 6px; background: #333; color: white;">
        <input type="email" id="ticketEmail" placeholder="La tua email" style="width: 100%; margin-bottom: 0.5rem; padding: 0.5rem; border: 1px solid #555; border-radius: 6px; background: #333; color: white;">
        <textarea id="ticketMessage" placeholder="Il tuo messaggio..." style="width: 100%; height: 80px; margin-bottom: 1rem; padding: 0.5rem; border: 1px solid #555; border-radius: 6px; background: #333; color: white; resize: vertical;"></textarea>
        <div style="display: flex; gap: 10px;">
          <button onclick="cancelTicketForm()" style="background: #6b7280; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer; font-weight: bold; flex: 1;">‚ùå Annulla</button>
          <button onclick="submitTicket()" style="background: #dc2626; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer; font-weight: bold; flex: 1;">üì® Invia messaggio</button>
        </div>
      </div>
    `;

    // Aggiungi form come messaggio HTML
    const ticketDiv = document.createElement('div');
    ticketDiv.className = 'chat-message bot';
    ticketDiv.innerHTML = `<div class="message-bubble">${ticketHtml}</div>`;
    messagesContainer.appendChild(ticketDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }

  // Cancel ticket form
  window.cancelTicketForm = function() {
    const form = document.querySelector('.ticket-form');
    if (form) {
      const messageContainer = form.closest('.chat-message');
      if (messageContainer) {
        messageContainer.remove();
      }
    }
    // Re-enable input if we're in AI mode
    if (!isOperatorMode) {
      setInputState(true);
      input.placeholder = 'Scrivi un messaggio...';
    }
    addMessage('Operazione annullata. Posso aiutarti con qualcos\'altro?', 'bot');
  };

  // ‚úÖ UPDATED: Ticket creation with new schema
  window.submitTicket = async function() {
    const name = document.getElementById('ticketName')?.value;
    const email = document.getElementById('ticketEmail')?.value;
    const message = document.getElementById('ticketMessage')?.value;

    if (!name || !email || !message) {
      alert('Compila tutti i campi');
      return;
    }

    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      alert('Inserisci un indirizzo email valido');
      return;
    }

    try {
      const response = await fetch(`${BACKEND_URL}/api/tickets`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sessionId: sessionId,
          userName: name,
          contactMethod: 'EMAIL',
          email: email,
          initialMessage: message,
          priority: 'NORMAL'
        })
      });

      const data = await response.json();

      if (response.ok && data.success && data.data?.ticket) {
        // Rimuovi l'intero messaggio che contiene il form (non solo il form)
        const form = document.querySelector('.ticket-form');
        if (form) {
          // Rimuovi il parent message container per evitare balloon vuoto
          const messageContainer = form.closest('.chat-message');
          if (messageContainer) {
            messageContainer.remove();
          } else {
            form.remove(); // Fallback
          }
        }
        // Poi aggiungi il messaggio di conferma
        addMessage(`‚úÖ Ticket creato! Ti ricontatteremo al pi√π presto via email.`, 'bot');

        // v2.3.4: Show recovery options after ticket creation
        const actions = [
          {
            icon: 'ü§ñ',
            text: 'Continua con Lucy',
            description: 'Torna all\'assistente virtuale',
            type: 'primary',
            action: 'start_fresh_chat'
          },
          {
            icon: '‚ùå',
            text: 'Chiudi',
            description: 'Chiudi la chat',
            type: 'secondary',
            action: 'close_widget'
          }
        ];
        showSmartActions(actions);
      } else {
        throw new Error(data.error?.message || 'Errore creazione ticket');
      }

    } catch (error) {
      console.error('‚ùå Errore creazione ticket:', error);
      addMessage('‚ùå Errore nell\'invio del messaggio. Riprova o scrivi a üìß info@lucinedinatale.it', 'bot');
    }
  };

  // v2.3.5: Show user name collection form when operator joins
  function showUserNameForm() {
    console.log('üìù Showing user name form');

    const formHtml = `
      <div class="username-form" style="margin: 1rem 0; padding: 1rem; background: rgba(45, 45, 45, 0.8); border-radius: 12px; border: 1px solid rgba(255,255,255,0.2);">
        <h4 style="color: #f59e0b; margin-bottom: 0.5rem; font-size: 1.1rem;">üë§ Come ti chiami?</h4>
        <p style="color: #9ca3af; font-size: 0.9rem; margin-bottom: 1rem;">Cos√¨ posso rivolgermi a te nel modo giusto!</p>
        <input type="text" id="userNameInput" placeholder="Il tuo nome" style="width: 100%; margin-bottom: 1rem; padding: 0.5rem; border: 1px solid #555; border-radius: 6px; background: #333; color: white;">
        <div style="display: flex; gap: 10px;">
          <button onclick="skipUserName()" style="background: #6b7280; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer; font-weight: bold; flex: 1;">‚è≠Ô∏è Salta</button>
          <button onclick="submitUserName()" style="background: #f59e0b; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer; font-weight: bold; flex: 1;">‚úÖ Continua</button>
        </div>
      </div>
    `;

    // Add form as HTML message
    const formDiv = document.createElement('div');
    formDiv.className = 'chat-message bot';
    formDiv.innerHTML = `<div class="message-bubble">${formHtml}</div>`;
    messagesContainer.appendChild(formDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;

    // Focus on input
    setTimeout(() => {
      document.getElementById('userNameInput')?.focus();
    }, 100);
  }

  // Submit user name
  window.submitUserName = async function() {
    const nameInput = document.getElementById('userNameInput');
    const name = nameInput?.value?.trim();

    if (!name) {
      nameInput?.focus();
      return;
    }

    // Validate name (2-50 characters, letters and spaces only)
    if (name.length < 2 || name.length > 50) {
      alert('Inserisci un nome valido (2-50 caratteri)');
      return;
    }

    if (!/^[a-zA-Z√Ä-√ø\s]+$/.test(name)) {
      alert('Il nome pu√≤ contenere solo lettere e spazi');
      return;
    }

    try {
      // Send name to backend
      const response = await fetch(`${BACKEND_URL}/api/chat/session/${sessionId}/set-name`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ userName: name })
      });

      const data = await response.json();

      if (response.ok && data.success) {
        // Store name globally for ticket form pre-fill
        userName = name;
        console.log('‚úÖ User name saved:', userName);

        // Remove form
        const form = document.querySelector('.username-form');
        if (form) {
          const messageContainer = form.closest('.chat-message');
          if (messageContainer) {
            messageContainer.remove();
          }
        }

        // Add confirmation message
        addMessage(`‚úÖ Perfetto, ${userName}! Come posso aiutarti?`, 'operator');
      } else {
        throw new Error(data.error?.message || 'Errore salvataggio nome');
      }
    } catch (error) {
      console.error('‚ùå Errore salvataggio nome:', error);
      alert('Errore nel salvataggio del nome. Riprova.');
    }
  };

  // Skip user name entry
  window.skipUserName = function() {
    console.log('‚è≠Ô∏è User skipped name entry');

    // Remove form
    const form = document.querySelector('.username-form');
    if (form) {
      const messageContainer = form.closest('.chat-message');
      if (messageContainer) {
        messageContainer.remove();
      }
    }

    // Add message
    addMessage('Nessun problema! Come posso aiutarti?', 'operator');
  };

  // ========================
  // üì° SOCKET.IO CONNECTION
  // ========================

  function initializeSocketIO() {
    if (!sessionId) {
      console.log('‚ö†Ô∏è Cannot connect Socket.IO without sessionId');
      return;
    }

    if (socket && socket.connected) {
      console.log('‚úÖ Socket.IO already connected');
      return;
    }

    try {
      console.log('üîå Connecting to Socket.IO:', SOCKET_URL);
      socket = io(SOCKET_URL, {
        transports: ['websocket', 'polling'],
        reconnection: true,
        reconnectionDelay: 1000,
        reconnectionAttempts: 5
      });

      socket.on('connect', () => {
        console.log('‚úÖ Socket.IO connected');
        console.log('üîç Current sessionId:', sessionId);

        // Join chat session (use current value of sessionId)
        if (sessionId) {
          socket.emit('join_chat', { sessionId: sessionId });
          console.log('üì§ Emitted join_chat with sessionId:', sessionId);
        } else {
          console.error('‚ùå Cannot join chat: sessionId is undefined');
        }
      });

      socket.on('chat_joined', (data) => {
        console.log('‚úÖ Joined chat:', data);
      });

      socket.on('new_message', (data) => {
        console.log('üì® New message:', data);

        if (data.message && !displayedMessageIds.has(data.message.id)) {
          displayedMessageIds.add(data.message.id);

          const sender = data.message.type === 'user' ? 'user' :
                        data.message.type === 'operator' ? 'operator' : 'bot';

          addMessage(data.message.content, sender, data.message.operatorName, data.message.attachment);

          // Show smart actions if present
          if (data.message.smartActions && data.message.smartActions.length > 0) {
            showSmartActions(data.message.smartActions);
          }
        }
      });

      // Listen for operator messages (from dashboard operator)
      socket.on('operator_message', (data) => {
        console.log('üë§üí¨ Operator message received:', data);

        if (data.message && !displayedMessageIds.has(data.message.id)) {
          displayedMessageIds.add(data.message.id);

          // Hide typing indicator immediately when message arrives
          showTypingIndicator(false);

          addMessage(data.message.content, 'operator', data.message.operatorName, data.message.attachment);

          // P2.5: Increment badge if popup is closed
          if (!isPopupOpen) {
            updateBadge(unreadMessageCount + 1);
          }

          // P2.6 & P2.7: Notifications if popup closed or window not focused
          if (!isPopupOpen || !document.hasFocus()) {
            // Play sound notification
            playNotificationSound();

            // Show browser notification
            const operatorName = data.message.operatorName || 'Operatore';
            const messagePreview = data.message.content.length > 50
              ? data.message.content.substring(0, 50) + '...'
              : data.message.content;

            showBrowserNotification(
              `${operatorName} ha risposto`,
              messagePreview,
              { sessionId: sessionId, messageId: data.message.id }
            );
          }
        }
      });

      // P0.5: Listen for operator typing indicator
      socket.on('operator_typing', (data) => {
        if (data.sessionId === sessionId) {
          showTypingIndicator(data.isTyping, data.operatorName);
        }
      });

      socket.on('operator_assigned', (data) => {
        console.log('üë§ Operator assigned:', data);
        isOperatorMode = true;
        updateHeaderForOperatorMode();
        hideWaitingForOperator(); // FIX: Always hide waiting UI when operator is assigned
        // Don't add message here - backend already sends "si √® unito alla chat" message
      });

      socket.on('operator_request_sent', (data) => {
        console.log('‚è≥ Operator request sent:', data);
        showWaitingForOperator();
      });

      socket.on('operator_joined', (data) => {
        console.log('üë§ Operator joined:', data);
        console.log('üîÑ Switching to operator mode and hiding waiting UI...');

        isOperatorMode = true;
        updateHeaderForOperatorMode();
        hideWaitingForOperator();

        // v2.3.5: Show user name form instead of automatic greeting message
        // Skip the backend greeting message (it says "come ti chiami?" which we'll ask via form)
        if (data.message && !data.message.content.includes('come ti chiami')) {
          addMessage(data.message.content, 'system');
        }

        // Show name collection form
        showUserNameForm();

        // Re-enable input
        setInputState(true);
        input.placeholder = 'Scrivi un messaggio...';

        // Start inactivity check
        startInactivityCheck();

        console.log('‚úÖ Operator mode activated, waiting UI should be hidden');
      });

      // v2.3.4: Listen for user name captured event
      socket.on('user_name_captured', (data) => {
        console.log('üìù User name captured:', data);
        if (data.userName) {
          userName = data.userName;
          console.log('‚úÖ Stored user name for ticket form:', userName);
        }
      });

      socket.on('operator_request_cancelled', (data) => {
        console.log('üö´ Operator request cancelled:', data);
        hideWaitingForOperator();
        addMessage(data.message || 'Richiesta operatore annullata', 'system');

        // Re-enable input
        setInputState(true);
        input.placeholder = 'Scrivi un messaggio...';
      });

      socket.on('chat_closed', (data) => {
        console.log('üëã Chat closed:', data);
        addMessage('La chat √® stata chiusa. Grazie per averci contattato!', 'system');

        // Save sessionId before clearing (for rating)
        const closedSessionId = sessionId;

        // FIX: Clear session quando operatore chiude la chat (using correct function)
        clearSessionStorage(); // Clears both SESSION_STORAGE_KEY and SESSION_EXPIRY_KEY
        sessionId = null;
        sessionValidated = false; // Reset validation flag
        isOperatorMode = false;

        // Stop inactivity check
        stopInactivityCheck();

        // P1.7 Fix: Disable input after chat closed
        setInputState(false);
        input.placeholder = 'Chat chiusa';

        // Show smart actions for next steps
        // Calculate if chat was closed recently (<5 min) for reopen option
        const closedTime = Date.now();
        const actions = [];

        // Add "Riapri Chat" if closed less than 5 minutes ago
        actions.push({
          icon: 'üîÑ',
          text: 'Riapri Chat',
          description: 'Ho dimenticato qualcosa',
          type: 'primary',
          action: 'reopen_chat',
          data: { sessionId: closedSessionId, closedAt: closedTime }
        });

        actions.push({
          icon: 'üí¨',
          text: 'Nuova Chat',
          description: 'Inizia una nuova conversazione',
          type: 'secondary',
          action: 'start_fresh_chat'
        });

        actions.push({
          icon: '‚≠ê',
          text: 'Valuta',
          description: 'Valuta la tua esperienza',
          type: 'secondary',
          action: 'show_rating',
          data: { sessionId: closedSessionId }
        });

        showSmartActions(actions);

        console.log('‚úÖ Session cleared - next conversation will be new');
      });

      // Handle operator disconnect (connection lost, browser closed, etc.)
      socket.on('operator_disconnected', (data) => {
        console.log('üî¥ Operator disconnected:', data);

        // Save sessionId before clearing (for rating)
        const disconnectedSessionId = sessionId;

        addMessage('üî¥ L\'operatore non √® pi√π disponibile a causa di un problema tecnico.', 'system');

        // Clear session state
        clearSessionStorage();
        sessionId = null;
        sessionValidated = false;
        isOperatorMode = false;

        // Stop inactivity check
        stopInactivityCheck();

        // Disable input
        setInputState(false);
        input.placeholder = 'Operatore disconnesso';

        // Show smart actions for recovery options
        showSmartActions([
          {
            icon: 'üìã',
            text: 'Apri Ticket',
            description: 'Lascia i tuoi contatti, ti ricontatteremo',
            type: 'primary',
            action: 'request_ticket'
          },
          {
            icon: 'ü§ñ',
            text: 'Continua con AI',
            description: 'Prova l\'assistente automatico',
            type: 'secondary',
            action: 'start_fresh_chat'
          },
          {
            icon: '‚≠ê',
            text: 'Valuta',
            description: 'Valuta la tua esperienza',
            type: 'secondary',
            action: 'show_rating',
            data: { sessionId: disconnectedSessionId }
          }
        ]);

        console.log('‚úÖ Operator disconnect handled - recovery options shown');
      });

      // Handle operator not responding (accepted chat but never sent message)
      socket.on('operator_not_responding', (data) => {
        console.log('‚è±Ô∏è Operator not responding:', data);

        // Save sessionId before clearing (for rating)
        const timeoutSessionId = sessionId;

        addMessage('‚è±Ô∏è L\'operatore non ha risposto entro il tempo previsto.', 'system');

        // Clear session state
        clearSessionStorage();
        sessionId = null;
        sessionValidated = false;
        isOperatorMode = false;

        // Stop inactivity check
        stopInactivityCheck();

        // Disable input
        setInputState(false);
        input.placeholder = 'Operatore non disponibile';

        // Show smart actions for recovery options
        showSmartActions([
          {
            icon: 'üìã',
            text: 'Apri Ticket',
            description: 'Lascia i tuoi contatti, ti ricontatteremo',
            type: 'primary',
            action: 'request_ticket'
          },
          {
            icon: 'ü§ñ',
            text: 'Continua con AI',
            description: 'Prova l\'assistente automatico',
            type: 'secondary',
            action: 'start_fresh_chat'
          },
          {
            icon: '‚≠ê',
            text: 'Valuta',
            description: 'Valuta la tua esperienza',
            type: 'secondary',
            action: 'show_rating',
            data: { sessionId: timeoutSessionId }
          }
        ]);

        console.log('‚úÖ Operator timeout handled - recovery options shown');
      });

      // Handle WAITING timeout (no operator accepted within 5 min)
      socket.on('operator_wait_timeout', (data) => {
        console.log('‚è±Ô∏è WAITING timeout:', data);

        addMessage('‚è±Ô∏è Nessun operatore ha risposto entro il tempo previsto.', 'system');

        // Clear WAITING state
        isOperatorMode = false;
        setInputState(true);

        // Show recovery options
        showSmartActions([
          {
            icon: 'üìã',
            text: 'Apri Ticket',
            description: 'Lascia i tuoi contatti',
            type: 'primary',
            action: 'request_ticket'
          },
          {
            icon: 'ü§ñ',
            text: 'Continua con AI',
            description: 'Prova l\'assistente automatico',
            type: 'secondary',
            action: 'continue_ai'
          }
        ]);

        console.log('‚úÖ WAITING timeout handled - recovery options shown');
      });

      // Handle chat auto-closed (user didn't return after 5 min)
      socket.on('chat_auto_closed', (data) => {
        console.log('üîí Chat auto-closed:', data);
        // User-side: just log, session already cleared
      });

      // Handle chat reopened
      socket.on('chat_reopened', (data) => {
        console.log('üîÑ Chat reopened:', data);

        // Add system message
        if (data.message) {
          addMessage(data.message.content, 'system');
        }

        // Ensure operator mode is active
        isOperatorMode = true;
        updateHeaderForOperatorMode();
        setInputState(true);
        input.placeholder = `Scrivi a ${data.operatorName || 'operatore'}...`;
      });

      // v2.3.4: User inactivity presence check
      socket.on('user_presence_check', (data) => {
        console.log('‚è±Ô∏è User presence check:', data);

        // Add system message
        addMessage(data.message || 'Sei ancora qui? Hai ancora bisogno di aiuto?', 'system');

        // Show smart actions with countdown
        const countdown = data.countdown || 300; // seconds
        const actions = [
          {
            icon: '‚úÖ',
            text: 'S√¨ sono qui',
            description: `La chat si chiuder√† tra ${Math.floor(countdown / 60)} minuti`,
            type: 'primary',
            action: 'confirm_presence'
          },
          {
            icon: 'ü§ñ',
            text: 'Continua con AI',
            description: 'Passa all\'assistente automatico',
            type: 'secondary',
            action: 'switch_to_ai'
          }
        ];

        showSmartActions(actions);

        // Start countdown update (update every 30 seconds)
        let remainingSeconds = countdown;
        const countdownInterval = setInterval(() => {
          remainingSeconds -= 30;

          if (remainingSeconds <= 0) {
            clearInterval(countdownInterval);
            return;
          }

          // Update button description with remaining time
          const actionButton = document.querySelector('.smart-action-button.primary .action-description');
          if (actionButton) {
            const minutes = Math.floor(remainingSeconds / 60);
            const seconds = remainingSeconds % 60;
            actionButton.textContent = `La chat si chiuder√† tra ${minutes}:${seconds.toString().padStart(2, '0')}`;
          }
        }, 30000); // Update every 30 seconds

        // Clean up interval if user clicks a button
        const smartActions = document.querySelector('.smart-actions-container');
        if (smartActions) {
          const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
              if (mutation.type === 'childList' && mutation.removedNodes.length > 0) {
                clearInterval(countdownInterval);
                observer.disconnect();
              }
            });
          });
          observer.observe(smartActions.parentElement, { childList: true });
        }
      });

      // v2.3.4: Chat closed due to user inactivity
      socket.on('chat_closed_inactivity', (data) => {
        console.log('üîí Chat closed due to inactivity:', data);

        addMessage(
          data.message || 'La chat √® stata chiusa per inattivit√†. Puoi iniziare una nuova conversazione quando vuoi!',
          'system'
        );

        // Clear session state
        clearSessionStorage();
        sessionId = null;
        sessionValidated = false;
        isOperatorMode = false;

        // Stop inactivity check
        stopInactivityCheck();

        // Disable input
        setInputState(false);
        input.placeholder = 'Chat chiusa per inattivit√†';

        // Show smart actions for next steps
        const actions = [
          {
            icon: 'üí¨',
            text: 'Nuova Chat',
            description: 'Inizia una nuova conversazione',
            type: 'primary',
            action: 'start_fresh_chat'
          },
          {
            icon: '‚≠ê',
            text: 'Valuta',
            description: 'Valuta la tua esperienza',
            type: 'secondary',
            action: 'show_rating',
            data: { sessionId: data.sessionId }
          }
        ];

        showSmartActions(actions);
      });

      socket.on('disconnect', (reason) => {
        console.log('üëã Socket.IO disconnected:', reason);
        if (reason === 'io server disconnect' || reason === 'io client disconnect') {
          // Intentional disconnect, don't show reconnecting
          return;
        }
        handleReconnecting();
      });

      socket.on('connect', () => {
        console.log('‚úÖ Socket.IO connected');
        if (reconnectAttempts > 0) {
          // Was reconnecting, now connected
          handleOnline();
        }
      });

      socket.on('connect_error', (error) => {
        console.error('‚ùå Socket.IO connection error:', error);
        handleReconnecting();
      });

      socket.on('reconnect_attempt', (attemptNumber) => {
        console.log(`üîÑ Reconnect attempt ${attemptNumber}`);
        handleReconnecting();
      });

      socket.on('reconnect_failed', () => {
        console.error('‚ùå Reconnection failed after all attempts');
        handleOffline();
      });

    } catch (error) {
      console.error('‚ùå Socket.IO initialization error:', error);
    }
  }

  // Initialize Socket.IO if we have a session
  if (sessionId) {
    initializeSocketIO();
  }

  // BUG #7 FIX: Cleanup interval on page unload to prevent memory leak
  window.addEventListener('beforeunload', () => {
    if (settingsRefreshInterval) {
      clearInterval(settingsRefreshInterval);
      console.log('üßπ Cleaned up settings refresh interval');
    }
  });
}
</script>
